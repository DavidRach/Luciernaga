---
title: "Getting Started"
author:
- name: David Rach
  affiliation: University of Maryland, Baltimore
  email: drach@som.umaryland.edu
package: Luciernaga
output:
  BiocStyle::html_document
abstract: |
  How to set up Luciernaga
vignette: |
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
Spectral flow cytometry (SFC) is heavily dependent on the quality of it's unmixing controls (both single-color (SC) and unstained (UC)) to resolve the presence and relative abundance of fluorophores on individual cells in the full-stained sample. Despite this critical role, there is a scarecity of tools and resources to check quality control of these unmixing controls in either open-source or commercial softwares. The individual user is only alerted to issues when the final unmixed .fcs file looks off, and is left to parsel out whether the issue is multiple autofluorescences, tandem degradation, or instrumental error on their own by individually replacing individual unmixing controls and attempting to re-unmix again and see if the issue has resolved. 

Our R package Luciernaga is aimed at addressing this gap. It provides functions to perfirn quality control checks of unmixing controls, interrogate normalized signatures present within individual .fcs files, and visualize the resulting data. 

These work at the individual experiment basis, but can also be combined to visualize changes in fluorescence across an experimental run to identify trends affecting single color quality. Our goal is to provide tools that others can use to further develop quantitative methods to monitor their own individual panels and instrumental configurations. We additionally leverage functional programming ability of the `r CRANpkg("purrr")` to enable data visualization of all markers present with the resulting unmixed samples, as well as all samples present within a GatingSet at a desired gating node. 

Luciernaga is an open-source project under active development, and we would love your feedback. It was originally designed to address issues for Cytek Aurora instruments. If you identify any bugs, please open an issue on the github page. If you have suggestions or would like to participate in extending the functionality to other spectral cytometry instruments, please reach out to the email listed in the description. 

#How to Begin

## Setup

### Installing Luciernaga

Luciernaga will be submitted to Bioconductor later this year, for the moment, it is available to install via GitHub. 

```{r Install Luciernaga, eval = FALSE, echo=FALSE}
# if(!require("remotes")) {install.packages("remotes")}
# remotes::install_github("https://github.com/DavidRach/Luciernaga")

# install.packages("BiocManager")
# BiocManager::install("Luciernaga")
```

### Loading Libraries

Luciernaga works using infrastructure provided by other Bioconductor cytometry packages. It also utilizes a few of the tidyverse packages available via CRAN. It is important to make sure that these are installed on your computer and then that the libraries are loaded. 

```{r, echo=FALSE, results = "hide", warning=FALSE}
suppressPackageStartupMessages({
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
})
```

```{r Load Libraries}
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
```

### Locating .fcs files
To get started, you will first need to provide the location on your computer where the .fcs files of interest are being stored. An example of how the author does this is provided below and can be modified for your own user and desired computer folder. 

```{r Additional Example, eval = FALSE}
File_Location <- file.path("C:", "Users", "JohnDoe", "Desktop", "TodaysExperiment")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern, full.names = TRUE, recursive = FALSE)
```

For this vignette, we will using several small .fcs files that can be found in Luciernaga's extdata folder for our example. 

```{r Access Package Data}
File_Location <- system.file("extdata", package = "Luciernaga")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern, full.names = TRUE, recursive = FALSE)
FCS_Files
```
Three of these files are raw unmixing controls (APCFire810, BUV496, Unstained), while the others are unmixed full-stained samples from a 29-color SFC panel (ND050). For now, let's subset the desired files to only select the raw .fcs unmixing controls as shown below:

```{r Selecting Desired Files}
SubsetFCSFiles <- FCS_Files[c(1:2, 6)]
SubsetFCSFiles
```

### Creating a GatingSet
Once we have the list of desired .fcs files, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyCytoSet <- load_cytoset_from_fcs(SubsetFCSFiles, truncate_max_range = FALSE, transform = FALSE)
MyCytoSet
MyGatingSet <- GatingSet(MyCytoSet)
MyGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the lymphocyte population. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```


For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, echo=FALSE, results="FALSE"}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyGatingSet)
MyGatingSet[[1]]
```

## Data Visualization

### Utility_GatingPlots

We can visualize our applied gates on their individual .fcs files using Luciernaga's `Utility_GatingPlots()` function. We can do this individually, or iterate over the entire GatingSet using the `r CRANpkg("purrr")` `purrr::map()` function. 

To do this, we reference the `r CRANpkg("data.table")` imported gating information (MyGates) showcased above, and the GatingSet object. `Utility_GatingPlots()` argument export = FALSE will return a `r CRANpkg("patchwork")` grouped ggplot objects, return = TRUE returns the same output in a .pdf file to the designated output location.

```{r}
removestrings <-  c("DR_", "Cells", ".fcs", "-", " ")
StorageLocation <- file.path("C:/", "Users", "JohnDoe", "Desktop")

IndividualPlot <- Utility_GatingPlots(x=MyGatingSet[[2]], sample.name = "GUID", removestrings = removestrings, gtFile = MyGates, DesiredGates = NULL, outpath = StorageLocation, export = FALSE)

IndividualPlot
  
IteratedPlots <- map(.x = MyGatingSet, .f = Utility_GatingPlots, sample.name = "GUID", removestrings = removestrings, gtFile = MyGates, DesiredGates = NULL, outpath = StorageLocation, export = FALSE)
```

### Utility_IterativeGating

In the absence of an existing gating template, the `Utility_IterativeGating()` function can be used to visualize individual gate placements for specimens found in a GatingSet object. To figure out the necessary information, we can use `r Biocpkg("flowWorkspace")`
`flowWorkspace::plot()` and `flowWorkspace::gs_pop_get_gate()` to find out the gate, and the respective X and Y parameters. 

```{r}
plot(MyGatingSet)
gs_pop_get_gate(MyGatingSet[1], "lymphocytes")

SingleSpecimen <- Utility_IterativeGating(x=MyGatingSet[1], sample.name = "GUID", removestrings = removestrings, subset = "nonDebris",
                        gate = "lymphocytes", xValue = "FSC-A", yValue = "SSC-A", bins = 270)

SingleSpecimen

AllSpecimens <- Utility_IterativeGating(x=MyGatingSet, sample.name = "GUID", removestrings = removestrings, subset = "nonDebris",
                        gate = "lymphocytes", xValue = "FSC-A", yValue = "SSC-A", bins = 270)
```

### Utility_Patchwork

The previous example returned AllSpecimens, which is a list of ggplot objects. This allows us to showcase `Utility_Patchwork()`. It is a wrapper for `r CRANpkg("patchwork")` that is used in the background by Luciernaga's data visualization functions when generating .pdf files from existing ggplot objects.

`Utility_Patchwork()` will take the list of ggplot objects, arrange them based on the specified number of columns and rows into individual pages of designated width and height, and when returntype = "pdf" save them to the designated outfolder file.path with the desired file.name. 

```{r}
StorageLocation <- file.path("C:/", "Users", "JohnDoe", "Desktop")
Utility_Patchwork(AllSpecimens, "LymphocyteGates", outfolder=StorageLocation, thecolumns=2, therows=2, width = 7, height = 9, returntype="patchwork")
```


### Creating a GatingSet for Unmixed .fcs files
The next couple functions are designed primarily for use with unmixed full-stained samples. We will return to the earlier example and select the corresponding example .fcs files found within Luciernaga's extdata folder and bring them into a GatingSet object.

```{r}
UnmixedFCSFiles <- FCS_Files[c(3:5)]
UnmixedFCSFiles
```

```{r}
UnmixedCytoSet <- load_cytoset_from_fcs(UnmixedFCSFiles, truncate_max_range = FALSE, transform = FALSE)
UnmixedGatingSet <- GatingSet(UnmixedCytoSet)
UnmixedGatingSet
```

Now that they are in a GatingSet object, we will identify markers/fluorophores present for the .fcs file, and remove from the list markers that don't need to be transformed (example FSC, SSC, etc). We will then bi-exponentially transform the data using `r Biocpkg("flowWorkspace")` `flowWorkspace::flowjo_biexp_trans()` before applying a gating template. 

```{r}
Markers <- colnames(UnmixedCytoSet)
KeptMarkers <- Markers[-grep("Time|FS|SC|SS|Original|-W$|-H$|AF", Markers)]

MyBiexponentialTransform <- flowjo_biexp_trans(channelRange = 256, maxValue = 1000000, pos = 4.5, neg = 0, widthBasis = -1000)
TransformList <- transformerList(KeptMarkers, MyBiexponentialTransform)
UnmixedGatingSet <- transform(UnmixedGatingSet, TransformList)

FileLocation <- system.file("extdata", package = "Luciernaga")
UnmixedGates <- fread(file.path(path = FileLocation, pattern = 'GatesUnmixed.csv'))
UnmixedGating <- gatingTemplate(UnmixedGates)
gt_gating(UnmixedGating, UnmixedGatingSet)
```

And to verify successfully gated as we expected:

```{r}
plot(UnmixedGatingSet)

UnmixedIndividualPlot <- Utility_GatingPlots(x=UnmixedGatingSet[[2]], sample.name = "GUID", removestrings = removestrings, gtFile = UnmixedGates, DesiredGates = NULL, outpath = StorageLocation, export = FALSE)

UnmixedIndividualPlot
```


### Utility_NxNPlots

`Utility_NxNPlots()` is a convenient function to visualize unmixed .fcs files for every marker compared to a reference marker. It is particularly useful in identifying cell populations, as well as unmixing errors. It takes a GatingSet object that has been transformed and gated. The desired population of cells can then be specified by the gatesubset argument. ycolumn specifies the desired marker to compare all the other markers to. Similar to other functions that use Utility_Patchwork behind the scenes, it can send the outputs for each specimen to their own pdf file. 

```{r}
plot(UnmixedGatingSet)
removethese <- c(".fcs", "DTR_")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualNxN <- Utility_NbyNPlots(x=UnmixedGatingSet[[1]], sample.name = "GROUPNAME", removestrings = removethese, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "Spark Blue 550-A", bins = 120, clearance = 0.2, gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)


MultipleNxN <- map(.x = UnmixedGatingSet, .f = Utility_NbyNPlots, sample.name = "GROUPNAME", removestrings = removethese, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "Spark Blue 550-A", bins = 120, clearance = 0.2, gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)
```

The return is for a given specimen all markers vs. the specified marker on the y-axis. `Utility_NxNPlots()` additionally accepts a ycolumn = "ALL" option that will directly iterate over every marker as the ycolumn argument. However, be warned, for larger SFC panels with many fluorophores, it will take time for a single specimen (and each marker pdf taking up memory space!), and even more so over every specimen in a GatingSet!!!

```{r, eval = FALSE}
removethese <- c(".fcs", "DTR_")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

# All_IndividualNxN <- Utility_NbyNPlots(x=UnmixedGatingSet[[1]], sample.name = "GROUPNAME", removestrings = removethese, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "ALL", bins = 120, clearance = 0.2, gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)


### ALL_MultipleNxN <- map(.x = UnmixedGatingSet, .f = Utility_NbyNPlots, sample.name = "GROUPNAME", removestrings = removethese, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "ALL", bins = 120, clearance = 0.2, gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)
```

### Utility_ParallelNxNPlots

`Utitlity_ParallelNxNPlots` is an extension of `Utility_NxNPlots`, but is used to compare two separate samples that are overlaid on the same plot. This can be useful when comparing different specimens, different treatment conditions, and differences in unmixing. It is usable but remains under development (notice the colors from the different specimens don't blend well). It utilizes the `r CRANpkg("purrr")` `purrr::map2()` argument behind the scenes to determine the order of what specimens are compared.  to each other. 

```{r}
gt(pData(UnmixedGatingSet))

OverlaidNxNPlots <- Utility_ParallelNbyNPlots(x=UnmixedGatingSet[1], y = UnmixedGatingSet[2], sample.name = "GROUPNAME", removestrings = ".fcs", Override = FALSE, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "Spark Blue 550-A", bins = 120, clearance = 0.2, colorX = "lightblue", colorY = "orange", gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)

OverlaidNxNPlots

# IteratedOverlaidNxNPlots <- map2(.x=UnmixedGatingSet[[1]], .y = UnmixedGatingSet[[3]], .f=Utility_ParallelNbyNPlots, sample.name = "GROUPNAME", removestrings = ".fcs", Override = FALSE, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "Spark Blue 550-A", bins = 120, clearance = 0.2, colorX = "lightblue", colorY = "orange", gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)
```

Similar to `Utility_NxNPlots()`, switching the argument ycolumn = "ALL" will iterate over all marker combinations for y-column vs all x-marker combinations. The same warning about run time and memory space applies, but double it as we are overlaying plots. 

```{r}
gt(pData(UnmixedGatingSet))

All_OverlaidNxNPlots <- Utility_ParallelNbyNPlots(x=UnmixedGatingSet[1], y = UnmixedGatingSet[2], sample.name = "GROUPNAME", removestrings = ".fcs", Override = FALSE, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "ALL", bins = 120, clearance = 0.2, colorX = "lightblue", colorY = "orange", gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)

All_OverlaidNxNPlots

# All_IteratedOverlaidNxNPlots <- map2(.x=UnmixedGatingSet[[1]], .y = UnmixedGatingSet[[3]], .f=Utility_ParallelNbyNPlots, sample.name = "GROUPNAME", removestrings = ".fcs", Override = FALSE, marginsubset = "lymphocytes", gatesubset = "live", ycolumn = "ALL", bins = 120, clearance = 0.2, colorX = "lightblue", colorY = "orange", gatelines = FALSE, reference = NULL, outpath = StorageLocation, pdf = FALSE)
```



### Utility_UnityPlots

```{r}


```





The working unit for most of Luciernaga's functions is a GatingSet object. Let's now workthrough the main Luciernaga function to characterize single color reference controls. First, let's provide a .csv file to provide information about where to expect to have overlapping autofluorescent signatures with fluorophore signatures. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
AutofluorescentOverlaps <- fread(file.path(path = FileLocation, pattern = "AutofluorescentOverlaps.csv"))
AutofluorescentOverlaps
```

We are now setup to run the main Luciernaga function. What this function does is it brings in the individual raw .fcs files, and on a per cell basis identifies which detector has the peak fluorescent emission. For example, single color stained cells have their fluorescent emission peak on R1-A, unstained PBMCs have their fluorescent emission peak on V7-A. 


Luciernaga will then identify which detectors had the most emission peaks, remove autofluorescent detectors with exceptions listed in the overlap list provided above. As a result, cells that are stained with your single-color stain are retained, while unstained autofluorescent cells are excluded. 

Retained single color-stain cells then have an average autofluorescence signature subtracted (either using the internal calculation or one externally provided), and are normalized for peak fluorescent signature. The cells are then clustered into shared signature bins. Cells that share the same signature are then exported as .raw fcs files with the subcluster name appended to the file for subsequent use. 


```{r, eval=FALSE}
    Unstained <- map(MyGatingSet[1], Utility_SingleColorQC, subsets = "lymphocytes",
        sample.name = "GUID", group.name = "GROUPNAME", experiment = NULL,
        experiment.name = "$DATE", stats = "median", Kept = "Normalized",
        external = NULL, sourcelocation = NULL, outpath = MainOutPath,
        artificial = FALSE, fcsexport = FALSE, mainAF = "V7-A",
        AFOverlap = AutofluorescentOverlaps, Beads = FALSE, Brightness = TRUE, 
        Unstained = FALSE) %>%
        bind_rows()
```

In addition to the exported .fcs files, the function also returns lineplots used in the fluorescent peak identifications for visual
inspection, as well as the following data.table: 


```{r, eval=FALSE}
gt(head(Unstained))
```

This in turn can be filtered using dplyr package for additional information. 

```{r, echo = FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
Panel <- fread(file.path(path = FileLocation, pattern = "Panel.csv"))
```




```{r sessionInfo, echo = FALSE}
sessionInfo()
```
