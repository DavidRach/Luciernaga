---
title: "06 Unmixing with `Luciernaga`"
date: "`r BiocStyle::doc_date()`"
author:
- name: David Rach
  email: drach@som.umaryland.edu
  affiliation: University of Maryland, Baltimore
package: "`r BiocStyle::pkg_ver('Luciernaga')`"
output:
  BiocStyle::html_document
bibliography: "`r file.path(system.file('extdata', package='Luciernaga'), 'refs.bib')`"
vignette: |
  %\VignetteIndexEntry{06 Unmixing}
  %\VignettePackage{Luciernaga}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

Unmixing is a black box for many spectral flow cytometry users, you adjust gates on your single color controls, you provide full-stained samples, you unmix and then you evaluate the outputs with NxN plots. The golden rules of reference controls (1. Single Color Controls as Bright or Brighter than Full-Stain Sample; 2. Unmixing Single Color should be the same fluorophore (even better same manufacturer and lot); 3. Single Color Controls should have autofluorescence subtracted from a matching/equivalent unstained sample; 4. enough events) are useful guidepost that obviously work but few have mechanistic explanations behind why. 

Building on examples from Jakob Theorell's `r Biocpkg("flowSpecs")` and Christopher Hall's [flowUnmix](https://github.com/hally166/flowUnmix) package, we implemented a way to take `Luciernaga_QC()` outputs of purified fluorophore signatures and unmix them using ordinal least squares (OLS) working from GatingSet objects, and returning FCS 3.0 standard files. In combination with functional programming principles, we have been leveraging this to understand how variations of fluorophore signature and brightness impact the unmixing of full-stained samples. We hope our addditive contribution enables users to push the limits of SFC and uncover new insights, write ways to handle issues arising from relative heterogeneity of individual immune cells unmixed with combination outputs, and spare future graduate students having to go write their own R package to answer space-wormhole questions. 

# Getting Started

This section uses the generated purified flourophore signatures generated by `Luciernaga_QC()` in the previous vignettes. 

Let's first load the required packages by calling them with library. 

```{r, echo=FALSE, results = "hide", warning=FALSE}
suppressPackageStartupMessages({
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
})
```

```{r}
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
```

Then we can find the .fcs files stored within the `Luciernaga` packages extdata folder and sort them by their respective type

```{r}
File_Location <- system.file("extdata", package = "Luciernaga")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,
                        full.names = TRUE, recursive = FALSE)
head(FCS_Files[10:30], 20)
```

```{r}
UnstainedFCSFiles <- FCS_Files[grep("Unstained", FCS_Files)]
UnstainedBeads <- UnstainedFCSFiles[grep("Beads", UnstainedFCSFiles)]
UnstainedCells <- UnstainedFCSFiles[-grep("Beads", UnstainedFCSFiles)]

BeadFCSFiles <- FCS_Files[grep("Beads", FCS_Files)]
BeadSingleColors <- BeadFCSFiles[-grep("Unstained", BeadFCSFiles)]

CellSingleColorFiles <- FCS_Files[grep("Cells", FCS_Files)]
CellSingleColors <- CellSingleColorFiles[!str_detect("Unstained", CellSingleColorFiles)]
```


Now lets create a GatingSet for our single-color cell unmixing controls

```{r}
MyCytoSet <- load_cytoset_from_fcs(CellSingleColors, 
                                   truncate_max_range = FALSE, 
                                   transform = FALSE)
MyCytoSet
MyGatingSet <- GatingSet(MyCytoSet)
MyGatingSet
```

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```

```{r, message = FALSE}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyGatingSet)
MyGatingSet[[1]]
```


Now lets create a GatingSet for our unstained cell unmixing controls

```{r}
MyUnstainedCytoSet <- load_cytoset_from_fcs(UnstainedCells, 
                                   truncate_max_range = FALSE, 
                                   transform = FALSE)
MyUnstainedCytoSet
MyUnstainedGatingSet <- GatingSet(MyUnstainedCytoSet)
MyUnstainedGatingSet
```

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```

```{r, message = FALSE}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyUnstainedGatingSet)
MyUnstainedGatingSet[[1]]
```
# Generate Luciernaga_QC Outputs

Now that the GatingSets are re-established, let's continue where the last vignette left off by processing all the fcs files with `Luciernaga_QC` to characterize the fluorescent signatures within. 

Let's first provision the AFOverlap csv to handle conflicts. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
AFOverlap_CSV <- read.csv(AFOverlap, check.names = FALSE)
AFOverlap_CSV
```

And next generate a CellAF unstained signature that can be used when these fluorophore-autofluorescence overlap files are encountered:

```{r}
# pData(MyUnstainedGatingSet[1])
removestrings <- c(".fcs")

TheCellAF <- map(.x=MyUnstainedGatingSet[1], .f=Luciernaga_QC, subsets="lymphocytes",
                              removestrings=removestrings, sample.name="GUID",
                              unmixingcontroltype = "cells", Unstained = TRUE,
                              ratiopopcutoff = 0.001, Verbose = FALSE,
                              AFOverlap = AFOverlap, stats = "median",
                              ExportType = "data", SignatureReturnNow = TRUE,
                              outpath = TemporaryFolder, Increments=0.1,
                              SecondaryPeaks=2, experiment = "FirstExperiment",
                              condition = "ILTPanel", SCData="subtracted",
                              NegativeType="default")

TheCellAF <- TheCellAF[[1]] #Removes list caused by map

gt(TheCellAF)
```


We will start with the ExportType = "data" return for now for both the cell Single-Color and Unstained Unmixing controls.

```{r}
SingleColor_Data <- map(.x=MyGatingSet, .f=Luciernaga_QC, subsets="lymphocytes",
                              removestrings=removestrings, sample.name="GUID",
                              unmixingcontroltype = "cells", Unstained = FALSE,
                              ratiopopcutoff = 0.001, Verbose = FALSE,
                              AFOverlap = AFOverlap, stats = "median",
                              ExportType = "data", SignatureReturnNow = FALSE,
                              outpath = TemporaryFolder, Increments=0.1,
                              SecondaryPeaks=2, experiment = "FirstExperiment",
                              condition = "ILTPanel", Subtraction = "Internal", 
                              CellAF=TheCellAF, SCData="subtracted",
                              NegativeType="default") %>% bind_rows()
```

```{r}
nrow(SingleColor_Data)
```

```{r}
gt(head(SingleColor_Data, 5))
```

Let's now repeat this process for the Unstained GatingSet. 

```{r}
# pData(MyUnstainedGatingSet)

Unstained_Data <- map(.x=MyUnstainedGatingSet, .f=Luciernaga_QC, subsets="lymphocytes",
                              removestrings=removestrings, sample.name="GUID",
                              unmixingcontroltype = "cells", Unstained = TRUE,
                              ratiopopcutoff = 0.001, Verbose = FALSE,
                              AFOverlap = AFOverlap, stats = "median",
                              ExportType = "data", SignatureReturnNow = FALSE,
                              outpath = TemporaryFolder, Increments=0.1,
                              SecondaryPeaks=2, experiment = "FirstExperiment",
                              condition = "ILTPanel", Subtraction = "Internal", 
                              CellAF=TheCellAF, SCData="subtracted",
                              NegativeType="default") %>% bind_rows()
```

```{r}
nrow(Unstained_Data)
```

```{r}
gt(head(Unstained_Data, 5))
```

# Luciernaga_Tree

We generate a lot of clusters with `Luciernaga_QC()`. We can visualize them using the report and plotting functions described in the previous vignettte, but selecting individual candidate output .fcs for use in unmixing can be tiresome and confusing. `Luciernaga_Tree()` is our initial attempt to reduce the burden, by instituting a decision tree to help filter the many outputs and return likely candidates that will work for unmixing. It relies on the `Luciernaga_QC()` Brightness=TRUE .csv outputs in making this decision. 

We want to be upfront and say this is developmental. We have recently created the tools to allow us to querry how fluorophore brightness, signature, and relative abundance impact the unmixing of full-stained samples. We have not had the time to delve into the outcomes at the depth we would like to come up with a grand unified theory of perfect unmixing. That is on my to-do-list as a postdoc/industry/whatever (hire me if this interest you or you want to avoid me working for your competitors). For the time, it works well enough, but with some notable bugs in the final unmixing. We highly encourage your feedback and tinkering with the decision trees step methodology in order to achieve more consistent results. 

For now, the process works as follows (detailed explanation logic)

```{r, eval = FALSE}
PanelPath <- file.path(ReferencePath, "TodaysBrightnessPanel.csv")

These <- Luciernaga_Tree(BrightnessFilePath = SCs_OutPath, PanelPath = PanelPath)
```

# Luciernaga_Move

Once `Luciernaga_Tree()` has identified the `Luciernaga_QC()` output .fcs files that will likely produce the best unmixing outcome, it would be absolutely brutal having to track down within a folder of hundreds of .fcs files with some repetition of CCR4BUV615_UV6_10-V7_08-B3_04 nomenclature (believe me, I did so initially). `Luciernaga_Move()` takes the `Luciernaga_Tree()` list of ideal candidates, and copies these .fcs files to a designated folder, saving you the hassle, and allowing you to simply point at that folder for use in the functions mentioned below. 

```{r, eval = FALSE}
PanelPath <- file.path(ReferencePath, "TodaysBrightnessPanel.csv")

These <- Luciernaga_Tree(BrightnessFilePath = SCs_OutPath, PanelPath = PanelPath)

Panel <- read.csv(PanelPath, check.names=FALSE)
Vector <- Panel %>% pull(Fluorophore)
Vector

walk(.x=Vector[c(1:28)], .f=Luciernaga_Move, data=These, input=SCs_OutPath, output=Selected_Outpath)
```

# Luciernaga_LinearSlices

We had previously showcased `Luciernaga_LinearSlices()` ability to take an .fcs file, and visualize variation in the signature based on the quantile splits for the MFI brightness. Our example was as follows. 

For today, we highlight the ability to do the same principle on the `Luciernaga_QC()` outputs, demonstrating that this variation in signature is not occuring, and that the sorting within `Luciernaga_QC()` appears to have sorted cells of similar signature regardless of brightness. These outputs can likewise be exported as a .pdf file that can be used for troubleshooting

```{r, eval = FALSE}
Selected_Files <- list.files(Selected_Outpath, pattern="fcs", full.names=TRUE)
Selected_CS <- load_cytoset_from_fcs(Selected_Files, truncate_max_range = FALSE, transform = FALSE)
Selected_GS <- GatingSet(Selected_CS)

ThePlots <- map(.x=Selected_GS, .f=Luciernaga_LinearSlices, subset="root", removestrings=".fcs",
                sample.name="GUID", stats="median", returntype="normalized", output="plot")

Utility_Patchwork(ThePlots, filename = "LinearSlices", outfolder=ReferencePath, returntype = "pdf")
```

# Luciernaga_SingleColors

The main purpose of `Luciernaga_SingleColors()` is to generate a reference matrix for use in unmixing full-stained samples. It additionally serves as a mechanism by which we can check the signatures that we are providing to the matrix and contrast them to reference signatures stored within `Luciernaga`. The outputed data.frame can be saved elsewhere and edited as desired, allowing for correction of any typos or format issues before creating unmixed .fcs files. 

```{r, eval = FALSE}
#pData(Selected_GS)
removestrings=c("DR_", ".fcs")
ThePanelCuts <- Panel %>% select(-Detector) %>% mutate(From=0.3) %>% mutate(To=1)

SCs <- map(.x=Selected_GS, .f=Luciernaga_SingleColors, sample.name="TUBENAME",
           removestrings=removestrings, subset="root", PanelCuts=ThePanelCuts,
           stats="median", Verbose=TRUE, SignatureView=TRUE, returntype = "plots")

Utility_Patchwork(x=SCs, filename="ReferenceMatches", outfolder = ReferencePath, returntype = "pdf")

SC_Reference <- map(.x=Selected_GS, .f=Luciernaga_SingleColors, sample.name="TUBENAME",
                    removestrings=removestrings, subset="root", PanelCuts=ThePanelCuts,
                    stats="median", Verbose=FALSE, SignatureView=FALSE, returntype = "data") %>%
                    bind_rows()

SC_Reference <- SC_Reference %>%
  mutate(Fluorophore = case_when(Fluorophore == "Unstained" ~ "AF", TRUE ~ Fluorophore))

TheSCReferences <- file.path(ReferencePath, "UnmixingSCs.csv")

write.csv(SC_Reference, TheSCReferences, row.names=FALSE)
```

# Luciernaga_Unmix

`Luciernaga_Unmix()` is the unmixing function implemented within the `Luciernaga` package. What mainly distinguishes it from other R package implementations of ordinary least squares unmixing is it works at the GatingSet level in terms of infrastructure (reducing active memory use) and is set up in such a way to allow us to rapidly iterate/modify/change the inputs to subsequently evaluate the unmixed full-stained .fcs files for the impacts that those decisions had on the unmixing. We have put some effort into ensuring that the subsequent unmixed files are compatible with various software typically used by those who prefer to use GUI for their flow data. This involved changes done within the newly produced .fcs files exprs, parameters and description folder, it's possible we may have missed something, so if you encounter a bug, please reach out. 

As previously stated, this remains experimental, and at the moment is just intended as a tool to allow me to querry how brightness/signature/abundance of individual single colors impacts the full-unmixing. As I improve on my existing knowledge, the quality of inputs/outputs is likely to also improve as I figure out the things that I don't yet know and correct for them. So consider this a work in progress for now, feel free to reach out if you know something I don't, and want to collaborate on getting it implemented here. 

```{r, eval = FALSE}
PanelPath <- file.path(ReferencePath, "TodaysNamePanel.csv")
SingleColorReference <- read.csv(TheSCReferences, check.names=FALSE)

FullStainLocation <- file.path(ReferencePath, "FullStainedSamples")
UnmixedOutpath <- file.path(ReferencePath, "Unmixed")
FilesForUnmixing <- list.files(FullStainLocation, pattern="fcs", full.names=TRUE)

UnmixCytoSet <- load_cytoset_from_fcs(FilesForUnmixing, truncate_max_range = FALSE, transform = FALSE)
UnmixGatingSet <- GatingSet(UnmixCytoSet)

TheSampleName <- c("GROUPNAME", "TUBENAME")
```

```{r, eval = FALSE}
UnmixSuccess <- map(.x=UnmixGatingSet, .f=Luciernaga_Unmix, controlData=SingleColorReference, sample.name=TheSampleName, addon="_TwoAF_Unmixed", subset="root", removestrings=".fcs", multiplier=50000, outpath=UnmixedOutpath, PanelPath=PanelPath, Verbose=FALSE)
```

# Luciernaga_IterativeUnmix

This function is an extension of `Luciernaga_Unmix()` using the same inputs, with the added provision that you provide it a folder of variant of `Luciernaga_QC()` .fcs files for a single fluorophore of interest. `Luciernaga_IterativeUnmix()` will then proceed one by one through the files in that folder, process them individually and swap them in to the Reference Matrix, unmix the full-stain samples, and return the variant unmixed full-stain files to the outfolder. It will repeat this until everything is complete. What we will do subsequently, is use `Utility_UnityPlots()` and `Utility_NxNPlots()` and the workflow described in Vignette 1 to consolidate all the variant unmixed files and evaluate how the variation in that iterated single-color impacted the final unmixing. 

```{r, eval = FALSE}
IterativePath <- file.path(ReferencePath, "DifferentialPerCP")
removestrings <- c("DR_", ".fcs")
iterate_removestrings <- c("DR_", "(Cells)", ".fcs", " ", "PerCP-Cy5.5", "CD26", "_")
TheSampleName <- c("GROUPNAME", "TUBENAME") 


Luciernaga_IterativeUnmixing(IterativePath=IterativePath, iterate_removestrings=iterate_removestrings,
                               removestrings=removestrings, sample.name=TheSampleName, subset="root",
                               PanelCuts=ThePanelCuts, stats="median", Verbose=FALSE, SignatureView=FALSE,
                               FullStainedGS=UnmixGatingSet, controlData=SingleColorReference, multiplier=50000,
                               outpath=UnmixedOutpath, PanelPath=PanelPath)
```

# Conclusion

And with that, we conclude our tour of the current state of the unmixing functions within the `Luciernaga` package. They remain a work in progress, and we welcome any contributions/insights/bug-reports to continue improving on them. This entire project arose when curious of how placing a positive gate on a single-color unmixing control would alter the unmixing of that file, and the sum of `Luciernaga`'s functions have been geared to allowing me to answer these questions so that no other graduate student will have to go through the horror of "it unmixed weird, no idea why" 20 years from now. 

```{r sessionInfo, echo = FALSE}
sessionInfo()
```
