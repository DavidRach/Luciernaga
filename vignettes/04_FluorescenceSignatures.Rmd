---
title: "04 Fluorescence Signatures"
date: "`r BiocStyle::doc_date()`"
author:
- name: David Rach
  email: drach@som.umaryland.edu
  affiliation: University of Maryland, Baltimore
package: "`r BiocStyle::pkg_ver('Luciernaga')`"
output:
  BiocStyle::html_document
bibliography: "`r file.path(system.file('extdata', package='Luciernaga'), 'refs.bib')`"
vignette: |
  %\VignetteIndexEntry{04 Fluorescence Signatures}
  %\VignettePackage{Luciernaga}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
In spectral flow cytometry (SFC), having good quality unmixing controls (both single color and unstained) is critical to the ability to take a full-stained sample and be able to decipher on an individual cell basis what fluorophore is present and the relative amount. Each single color unmixing control is itself a combination of the staining fluorophore and the underlying autofluorescence. Once autofluorescence is subtracted, the leftover signal should be distinct enough to be differentiated from other fluorophores in the reference matrix for unmixing using ordinary least squares to be effective. 

When the above assumptions are broken, we end up with uncertainty in the calculation, which becomes visible in the form of unmixing errors. However, despite the importance foundational to the final result, we have limited tools by which we can address the quality of our unmixing controls beyond trial and errors. 

This specific vignette addresses the Luciernaga functions that are focused on characterizing fluorescence signatures from individual .fcs files. They work on both unstained .fcs files where no subtraction takes place, as well as on single color .fcs files, where autofluorescent background (either internally or externally-derived) is first subtracted. The outputs can be either in a data.frame format that can be used for report generation, or as purified .fcs made up of populations of cells sharing the same normalized signature. 

This vignette will cover the pre-processing and report generation components of the process. For the Unmixing steps using the resulting files, please refer to the unmixing vignette. We hope this allows a better understanding of how fluorophore signature and brightness impacts the typically ordinal least squares methods that are used to unmix full-stained samples. 

# Getting Started

To use the following Luciernaga functions, we will be working with raw .FCS files that retain their detector information (ex. UV7-A, V7-A, B3-A, etc.). We will bring these files into GatingSets comprising both unstained and single color unmixing controls, divided by whether the reference controls are cells or beads for ease of explanation.

## Install Required Packages Libraries

Luciernaga relies on the infrastructure provided by other cytometry R packages like `r Biocpkg("flowCore")` and `r Biocpkg("flowWorkspace")` available through Bioconductor. It also relies on `r CRANpkg("tidyverse")` packages available via CRAN. It is important to make sure that each of the following packages is installed on your computer before beginning. If you are new to R, an example of how to do this is provided below: 

```{r, eval=FALSE}
# To Install a CRAN Package:
install.packages("dplyr")
install.packages("BiocManager")

# To Install a Bioconductor Package:
BiocManager::install("flowCore")
```

Once you have the packages installed, you make sure that their contents are accessible by calling them via library: 

```{r, echo=FALSE, results = "hide", warning=FALSE}
suppressPackageStartupMessages({
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
})
```

```{r}
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
```

## Locating .fcs files
To get started, you will first need to provide the location on your computer where the .fcs files of interest are being stored. An example of how the author does this is provided below and can be modified for your own user and desired computer folder. 

```{r}
File_Location <- file.path("C:", "Users", "JohnDoe", "Desktop",
                           "TodaysExperiment")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,
                        full.names = TRUE, recursive = FALSE)
```

For this vignette, we will using several small .fcs files that are stored in Luciernaga's extdata folder for use in our examples.

```{r}
File_Location <- system.file("extdata", package = "Luciernaga")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,
                        full.names = TRUE, recursive = FALSE)
head(FCS_Files[10:30], 20)
```

As you can see, there are a lot of different .fcs files that are used for different examples for the different vignettes, we will be selectively filtering from this list to get specific files that we need. 

```{r}
UnstainedFCSFiles <- FCS_Files[grep("Unstained", FCS_Files)]
UnstainedBeads <- UnstainedFCSFiles[grep("Beads", UnstainedFCSFiles)]
UnstainedCells <- UnstainedFCSFiles[-grep("Beads", UnstainedFCSFiles)]

BeadFCSFiles <- FCS_Files[grep("Beads", FCS_Files)]
BeadSingleColors <- BeadFCSFiles[-grep("Unstained", BeadFCSFiles)]

CellSingleColorFiles <- FCS_Files[grep("Cells", FCS_Files)]
CellSingleColors <- CellSingleColorFiles[!str_detect("Unstained", CellSingleColorFiles)]
```


## Creating a GatingSet Bead Single Colors
Now that we have filtered the .fcs files into smaller list, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyBeadsCytoSet <- load_cytoset_from_fcs(BeadSingleColors,
                                        truncate_max_range = FALSE,
                                        transform = FALSE)
MyBeadsCytoSet
```

```{r}
MyBeadsGatingSet <- GatingSet(MyBeadsCytoSet)
MyBeadsGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the bead singlets. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r, message=FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyBeadsGates <- fread(file.path(path = FileLocation, 
                                pattern = 'GatesBeads.csv'))
gt(MyBeadsGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message=FALSE}
MyBeadsGatingTemplate <- gatingTemplate(MyBeadsGates)
gt_gating(MyBeadsGatingTemplate, MyBeadsGatingSet)
MyBeadsGatingSet[[1]]
plot(MyBeadsGatingSet)
```

And finally check the gate placements using the `Utility_GatingPlots` function:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualBeadPlot <- Utility_GatingPlots(x=MyBeadsGatingSet[[1]], 
                                          sample.name = "GUID",
                                          removestrings = removestrings,
                                          gtFile = MyBeadsGates, 
                                          DesiredGates = NULL,
                                          outpath = StorageLocation,
                                          export = FALSE)

IndividualBeadPlot
```

```{r}
IteratedBeadPlots <- map(.x = MyBeadsGatingSet[1:3], .f = Utility_GatingPlots,
                         sample.name = "GUID", removestrings = removestrings,
                         gtFile = MyBeadsGates, DesiredGates = NULL,
                         outpath = StorageLocation, export = FALSE)
IteratedBeadPlots


#gs_pop_get_count_fast(MyBeadsGatingSet)
```


## Creating a GatingSet Cell Single Colors





Three of these files are raw unmixing controls (APCFire810, BUV496, Unstained), while the others are unmixed full-stained samples from a 29-color SFC panel (ND050). For now, let's subset the desired files to only select the raw .fcs unmixing controls as shown below:

```{r}
CellSingleColors <- FCS_Files[grep("Cells", FCS_Files)]
```

Once we have the list of desired .fcs files, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyCytoSet <- load_cytoset_from_fcs(CellSingleColors, 
                                   truncate_max_range = FALSE, 
                                   transform = FALSE)
MyCytoSet
MyGatingSet <- GatingSet(MyCytoSet)
MyGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the lymphocyte population. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message = FALSE}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyGatingSet)
MyGatingSet[[1]]
```

And finally check the gate placements using:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualPlot <- Utility_GatingPlots(x=MyGatingSet[[2]], 
                                      sample.name = "GUID", 
                                      removestrings = removestrings, 
                                      gtFile = MyGates, 
                                      DesiredGates = NULL, 
                                      outpath = StorageLocation, 
                                      export = FALSE)

#IndividualPlot
  
IteratedPlots <- map(.x = MyGatingSet, .f = Utility_GatingPlots, 
                     sample.name = "GUID", removestrings = removestrings,
                     gtFile = MyGates, DesiredGates = NULL,
                     outpath = StorageLocation, export = FALSE)

IteratedPlots[[2]]
```

# Luciernaga_QC

The working unit for most of Luciernaga's functions is a GatingSet object. Let's now workthrough the main Luciernaga function to characterize single color reference controls. First, let's provide a .csv file to provide information about where to expect to have overlapping autofluorescent signatures with fluorophore signatures. We are now setup to run the main Luciernaga function. What this function does is it brings in the individual raw .fcs files, and on a per cell basis identifies which detector has the peak fluorescent emission. For example, single color stained cells have their fluorescent emission peak on R1-A, unstained PBMCs have their fluorescent emission peak on V7-A. 

Luciernaga will then identify which detectors had the most emission peaks, remove autofluorescent detectors with exceptions listed in the overlap list provided above. As a result, cells that are stained with your single-color stain are retained, while unstained autofluorescent cells are excluded.

Retained single color-stain cells then have an average autofluorescence signature subtracted (either using the internal calculation or one externally provided), and are normalized for peak fluorescent signature. The cells are then clustered into shared signature bins. Cells that share the same signature are then exported as .raw fcs files with the subcluster name appended to the file for subsequent use. 

In addition to the exported .fcs files, the function also returns line plots used in the fluorescent peak identifications for visual
inspection, as well as the following data.table: 


The main workhorse of the Luciernaga is `LuciernagaQC`. Briefly, it will take individual raw .fcs files, process them and return distinct fluorescence signatures as their own .fcs files.

Let's work through it's compabilities individually. First off, let's profile Autofluorescence from the Unstained Cells. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)

removestrings <- ".fcs"

# ?Luciernaga_QC

Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
              removestrings=removestrings, sample.name="GUID", 
              unmixingcontroltype = "cells", Unstained = TRUE, 
              ratiopopcutoff = 0.001, Verbose = TRUE, 
              AFOverlap = AFOverlap, stats = "median",
              ExportType = "data.frame", SignatureReturnNow = TRUE, 
              outpath = NULL, Brightness = FALSE)
``` 

The important parameters for the above outputs where Verbose, ratiopopcutoff, stats, and SignatureReturnNow.

From our lymphocyte gated cells, Verbose = TRUE prints out the output of cells enumerated by their peak detector. We can see that the main autofluorescence from this sample was UV7, followed by V7 and V3.  With the ratiopopcutoff set at 0.001, we are returning any detector that had > 0.1% starting lymphocytes with their main peak present in that detector. 
Here is an example when we restrict it to detectors with 1% of starting lymphocytes:

```{r}
Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
              removestrings=removestrings, sample.name="GUID", 
              unmixingcontroltype = "cells", Unstained = TRUE, 
              ratiopopcutoff = 0.01, Verbose = TRUE, 
              AFOverlap = AFOverlap, stats = "median", 
              ExportType = "data.frame", SignatureReturnNow = TRUE,
              outpath = NULL, Brightness = FALSE)
``` 

The SignatureReturnNow short circuits the downstream analysis. It calculates the main autofluorescence by taking the most abundant detector, filtering those cells, and then taking the selected stat for each detector from those cells. It then returns these values as a data.frame. 

If by contrast, we wanted the signature of the second and third peak detectors (V7 and V3), we could do this by providing the parameter desiredAF = "V7" or "V3"

```{r, eval = FALSE, echo=FALSE}
UV7 <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
                     removestrings=removestrings, sample.name="GUID",
                      unmixingcontroltype = "cells", Unstained = TRUE,
                     ratiopopcutoff = 0.01, Verbose = FALSE, 
                     AFOverlap = AFOverlap, stats = "median",
                     ExportType = "data.frame", SignatureReturnNow = TRUE, 
                     outpath = NULL, Brightness = FALSE)

V7 <- Luciernaga_QC(x=MyGatingSet[2], desiredAF = "V7-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.01, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL, Brightness = FALSE)

V3 <- Luciernaga_QC(x=MyGatingSet[2], desiredAF = "V3-A", subsets="lymphocytes",
                    removestrings=removestrings, sample.name="GUID",
                    unmixingcontroltype = "cells", Unstained = TRUE,
                    ratiopopcutoff = 0.01, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median", 
                    ExportType = "data.frame", SignatureReturnNow = TRUE, 
                    outpath = NULL, Brightness = FALSE)

DifferentPeakDetectors <- bind_rows(UV7, V7, V3)
DifferentPeakDetectors
``` 

These data.frame consist of raw measurements from the .fcs file for the given detectors. These can be used by the xyz function to plot averaged normalized signature. Similarly, providing one of these data.frames containing a single row of our autofluorescence of interest can be used by the externalAF measurement to allow for subtraction of that reference from single color controls (to be discussed below). 

It's important before continuing to discuss the role of AFOverlap. Luciernaga works on the basis of filtering using the peak detectors, and then processsing out variations in signature from these filtered populations. Most fluorophores don't share overlaps with autofluorescence for peak detectors, but certain fluorophores will match either the primary or rarer autofluorescences in their primary detector (main examples are BUV496-A, BV510-A, Spark Blue 550-A). Since these vary by panel, and name of the fluorophore, we provision a .csv file that gets imported and is used for special handling of these fluorophores. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
TheAFOverlaps <- read.csv(AFOverlap, check.names = FALSE)
gt(TheAFOverlaps)
```

For your own systems, you can update the Unstained Main Detectors Autofluorescence list, and provide unique fluorophores that overlap to a .csv styled like the example above, and provide the file.path to that csv to `Utility_SingleColorQC()` to similarly handle the exceptions (more details to follow below). 

Once the AFOverlaps .csv has been updated, when `Utility_SingleColorQC()` processes a single color unmixing control and finds peak detectors, it will remove the peak detectors that match the Unstained row in AFOverlap, leaving only the single-color driven peaks to be used for further processing. 

In the case ofsingle color unmixing control (in this case, APC-Fire 750, the other specimen in our GatingSet):

```{r}
SC_InternalAF <- Luciernaga_QC(x=MyGatingSet[1], subsets="lymphocytes",
                               removestrings=removestrings, sample.name="GUID", 
                               unmixingcontroltype = "cells", Unstained = FALSE,
                               ratiopopcutoff = 0.01, Verbose = TRUE,
                               AFOverlap = AFOverlap, stats = "median",
                               ExportType = "data.frame",
                               SignatureReturnNow = TRUE, 
                               outpath = NULL, Brightness = FALSE)
SC_InternalAF
```

As you can see from the Verbose=TRUE return arguments, the main detector present in this sample was R7 (the single-color stained cells), but additional detector peaks are present for the autofluorescences we saw in the above example of the unstained cell. These can be extracted as data.frame values similar to the process above, including use of the desiredAF argument, for average signature plotting. The one caveat is they will include both fully unstained cells, as well as non-specific/dim staining cells for APC-Fire 750 that didn't exceed the brightness of the main autofluorescent signature. Luciernaga futher sorts these, so exporting these for future use is not recommended, but is useful for some initial visualization purposes. 

A special note about beads.
In the case of unstained bead controls, it's recommended to use externalAF in this manner. In our experience with UltraComp beads, there is rarely a single peak detector for unstained beads given their low background, which causes oversplitting due to instrumental noise into hundreds of signatures. This and the rest will be detailed as we continue into the example workthrough. 

Continuing, we will switch SignatureReturnNow to False. Each of the peak detectors that has more events than specified by the ratiopopcutoff will be passed on to the unstained autofluorescence processing module, which will filter by these peak detectors and proceed to characterize their peaks.

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
removestrings <- c(".fcs", "(Cells)")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes", sample.name="GUID",
              experiment = "Monocytes", condition = "exvivo",
              removestrings = removestrings, Verbose = TRUE,
              unmixingcontroltype="both", Unstained=FALSE,
              ratiopopcutoff = 0.01, AFOverlap=AFOverlap,
              desiredAF=NULL, externalAF = NULL, stats = "median",
              NegativeType = "default", Increments=0.1, SecondaryPeaks=2,
              ExportType = "data", outpath=StorageLocation,
              Brightness = TRUE, SignatureReturnNow = FALSE)
```

And for single-color controls:

```{r, eval = FALSE, echo=FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
removestrings <- c(".fcs", "(Cells)")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

Luciernaga_QC(x=MyGatingSet[1], subsets="lymphocytes",
              sample.name="GUID", experiment = "Monocytes", condition = "exvivo",
              removestrings = removestrings, Verbose = FALSE,
              unmixingcontroltype="both", Unstained=FALSE,
              ratiopopcutoff = 0.01, AFOverlap=AFOverlap, desiredAF="V3-A",
              externalAF = NULL, stats = "median",
              NegativeType = "artificial", ExportType = "fcs",
              outpath=StorageLocation, Brightness = TRUE,
              SignatureReturnNow = FALSE, minimalfcscutoff = 0.05,
              Subtraction = "Internal", SCData = "subtracted",
              Increments=0.1)
```

And finally, we can RetainedType = "normalized and ExportType = "data"
```{r, eval=FALSE}

Data <- Luciernaga_QC(x=MyGatingSet[1], subsets="lymphocytes",
                      sample.name="GUID", 
                      experiment = "Monocytes", condition = "exvivo",
                      removestrings = removestrings, Verbose = FALSE, 
                      unmixingcontroltype="both", Unstained=FALSE,
                      ratiopopcutoff = 0.01, AFOverlap=AFOverlap,
                      desiredAF=NULL, externalAF = NULL, stats = "median",
                      NegativeType = "artificial", ExportType = "data",
                      outpath=StorageLocation, Brightness = TRUE, 
                      SignatureReturnNow = FALSE, minimalfcscutoff = 0.05,
                      Subtraction = "Internal", SCData = "subtracted",
                      RetainedType="normalized", Increments=0.2)

CombinedData <- map(.x=MyGatingSet, .f=Luciernaga_QC, subsets="lymphocytes",
                    sample.name="GUID", experiment = "Monocytes", 
                    condition = "exvivo", removestrings = removestrings,
                    Verbose = FALSE, unmixingcontroltype="both", 
                    Unstained=FALSE, ratiopopcutoff = 0.01, AFOverlap=AFOverlap,
                    desiredAF=NULL, externalAF = NULL, stats = "median",
                    NegativeType = "artificial", ExportType = "data",
                    outpath=StorageLocation, Brightness = TRUE,
                    SignatureReturnNow = FALSE, minimalfcscutoff = 0.05,
                    Subtraction = "Internal", SCData = "subtracted",
                    RetainedType="normalized", Increments=0.2) %>% bind_rows()
```

### Luciernaga_Plots

We can take the data.frame output from LuciernagaQC and run directly into a basic report. CellPopRatio determines the mininum ratio a cluster needs to have to be plotted (anything smaller is combined into the other category). The default is set for all four plots being returned, these can be modified by specifying FALSE for their individual arguments. Outputs are sent to Utility_Patchwork for processing into either grouped ggplot or a pdf file. 

```{r, eval = FALSE, echo=FALSE}
ThePlots <- LuciernagaReport(data=CombinedData, RetainedType = "normalized",
                             CellPopRatio = 0.05, outfolder = NULL,
                             filename = NULL, returntype = "patchwork")

ThePlots
#ggplotly(ThePlots[[1]])
```


### Reports from .fcs files

The LuciernagaQC() will also produce .fcs files containing only the isolated signatures, and store these in the designated folder. Rather than re-running LuciernagaQC() just to return a report, and to allow for visualization of specific .fcs subfiles of interest, we have implemented functions that carry out similar functionality, but using these isolated fluorescent files as their start basis.

## Luciernaga_QC

## Luciernaga_FCSToReport

## Luciernaga_Brightness

## Luciernaga_Lists

## Luciernaga_Plots

# Conclusion

```{r sessionInfo, echo = FALSE}
sessionInfo()
```

