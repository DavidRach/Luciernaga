---
title: "04 Fluorescence Signatures"
date: "`r BiocStyle::doc_date()`"
author:
- name: David Rach
  email: drach@som.umaryland.edu
  affiliation: University of Maryland, Baltimore
package: "`r BiocStyle::pkg_ver('Luciernaga')`"
output:
  BiocStyle::html_document
bibliography: "`r file.path(system.file('extdata', package='Luciernaga'), 'refs.bib')`"
vignette: |
  %\VignetteIndexEntry{04 Fluorescence Signatures}
  %\VignettePackage{Luciernaga}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
In spectral flow cytometry (SFC), having good quality unmixing controls (both single color and unstained) is critical to the ability to take a full-stained sample and be able to decipher on an individual cell basis what fluorophore is present and the relative amount. Each single color unmixing control is itself a combination of the staining fluorophore and the underlying autofluorescence. Once autofluorescence is subtracted, the leftover signal should be distinct enough to be differentiated from other fluorophores in the reference matrix for unmixing using ordinary least squares to be effective. 

When the above assumptions are broken, we end up with uncertainty in the calculation, which becomes visible in the form of unmixing errors. However, despite the importance foundational to the final result, we have limited tools by which we can address the quality of our unmixing controls beyond trial and errors. 

This specific vignette addresses the Luciernaga functions that are focused on characterizing fluorescence signatures from individual .fcs files. They work on both unstained .fcs files where no subtraction takes place, as well as on single color .fcs files, where autofluorescent background (either internally or externally-derived) is first subtracted. The outputs can be either in a data.frame format that can be used for report generation, or as purified .fcs made up of populations of cells sharing the same normalized signature. 

This vignette will cover the pre-processing and report generation components of the process. For the Unmixing steps using the resulting files, please refer to the unmixing vignette. We hope this allows a better understanding of how fluorophore signature and brightness impacts the typically ordinal least squares methods that are used to unmix full-stained samples. 

# Getting Started

To use the following Luciernaga functions, we will be working with raw .FCS files that retain their detector information (ex. UV7-A, V7-A, B3-A, etc.). We will bring these files into GatingSets comprising both unstained and single color unmixing controls, divided by whether the reference controls are cells or beads for ease of explanation.

## Install Required Packages Libraries

Luciernaga relies on the infrastructure provided by other cytometry R packages like `r Biocpkg("flowCore")` and `r Biocpkg("flowWorkspace")` available through Bioconductor. It also relies on `r CRANpkg("tidyverse")` packages available via CRAN. It is important to make sure that each of the following packages is installed on your computer before beginning. If you are new to R, an example of how to do this is provided below: 

```{r, eval=FALSE}
# To Install a CRAN Package:
install.packages("dplyr")
install.packages("BiocManager")

# To Install a Bioconductor Package:
BiocManager::install("flowCore")
```

Once you have the packages installed, you make sure that their contents are accessible by calling them via library: 

```{r, echo=FALSE, results = "hide", warning=FALSE}
suppressPackageStartupMessages({
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
})
```

```{r}
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
```

## Locating .fcs files
To get started, you will first need to provide the location on your computer where the .fcs files of interest are being stored. An example of how the author does this is provided below and can be modified for your own user and desired computer folder. 

```{r}
File_Location <- file.path("C:", "Users", "JohnDoe", "Desktop",
                           "TodaysExperiment")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,
                        full.names = TRUE, recursive = FALSE)
```

For this vignette, we will using several small .fcs files that are stored in Luciernaga's extdata folder for use in our examples.

```{r}
File_Location <- system.file("extdata", package = "Luciernaga")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,
                        full.names = TRUE, recursive = FALSE)
head(FCS_Files[10:30], 20)
```

As you can see, there are a lot of different .fcs files that are used for different examples for the different vignettes, we will be selectively filtering from this list to get specific files that we need. 

```{r}
UnstainedFCSFiles <- FCS_Files[grep("Unstained", FCS_Files)]
UnstainedBeads <- UnstainedFCSFiles[grep("Beads", UnstainedFCSFiles)]
UnstainedCells <- UnstainedFCSFiles[-grep("Beads", UnstainedFCSFiles)]

BeadFCSFiles <- FCS_Files[grep("Beads", FCS_Files)]
BeadSingleColors <- BeadFCSFiles[-grep("Unstained", BeadFCSFiles)]

CellSingleColorFiles <- FCS_Files[grep("Cells", FCS_Files)]
CellSingleColors <- CellSingleColorFiles[!str_detect("Unstained", CellSingleColorFiles)]
```



## Creating a GatingSet Bead Single Colors
The bead single color controls are part of a 29-color SFC panel. They additionally have cell single color equivalents that we will compare to in a separate GatingSet in the next section. 

Now that we have filtered the .fcs files into smaller list, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyBeadsCytoSet <- load_cytoset_from_fcs(BeadSingleColors,
                                        truncate_max_range = FALSE,
                                        transform = FALSE)
MyBeadsCytoSet
```

```{r}
MyBeadsGatingSet <- GatingSet(MyBeadsCytoSet)
MyBeadsGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the bead singlets. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r, message=FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyBeadsGates <- fread(file.path(path = FileLocation, 
                                pattern = 'GatesBeads.csv'))
gt(MyBeadsGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message=FALSE}
MyBeadsGatingTemplate <- gatingTemplate(MyBeadsGates)
gt_gating(MyBeadsGatingTemplate, MyBeadsGatingSet)
MyBeadsGatingSet[[1]]
plot(MyBeadsGatingSet)
```

And finally check the gate placements using the `Utility_GatingPlots` function:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualBeadPlot <- Utility_GatingPlots(x=MyBeadsGatingSet[[1]], 
                                          sample.name = "GUID",
                                          removestrings = removestrings,
                                          gtFile = MyBeadsGates, 
                                          DesiredGates = NULL,
                                          outpath = StorageLocation,
                                          export = FALSE)

IndividualBeadPlot
```

```{r}
IteratedBeadPlots <- map(.x = MyBeadsGatingSet[1:3], .f = Utility_GatingPlots,
                         sample.name = "GUID", removestrings = removestrings,
                         gtFile = MyBeadsGates, DesiredGates = NULL,
                         outpath = StorageLocation, export = FALSE)
IteratedBeadPlots


#gs_pop_get_count_fast(MyBeadsGatingSet)
```
 
## Creating a GatingSet Cell Single Colors
These cell single color controls are part of 29-color SFC panel, they are the cell counterparts to the bead reference controls we worked with in the prior section. Having isolated the list of desired .fcs files at the start of the vignette, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyCytoSet <- load_cytoset_from_fcs(CellSingleColors, 
                                   truncate_max_range = FALSE, 
                                   transform = FALSE)
MyCytoSet
MyGatingSet <- GatingSet(MyCytoSet)
MyGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the lymphocyte population. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message = FALSE}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyGatingSet)
MyGatingSet[[1]]
```

And finally check the gate placements using:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualPlot <- Utility_GatingPlots(x=MyGatingSet[[2]], 
                                      sample.name = "GUID", 
                                      removestrings = removestrings, 
                                      gtFile = MyGates, 
                                      DesiredGates = NULL, 
                                      outpath = StorageLocation, 
                                      export = FALSE)

#IndividualPlot
  
IteratedPlots <- map(.x = MyGatingSet[1:2], .f = Utility_GatingPlots, 
                     sample.name = "GUID", removestrings = removestrings,
                     gtFile = MyGates, DesiredGates = NULL,
                     outpath = StorageLocation, export = FALSE)

IteratedPlots[[2]]
```

## Creating a GatingSet Bead Unstained
This unstained Bead cell control is by itself and could have been included in the Bead Single Color Gating Set, but we are including it in its own GatingSet for ease-of-locating reasons only. Now that we have filtered the .fcs file of interest, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyUnstainedBeadsCytoSet <- load_cytoset_from_fcs(UnstainedBeads,
                                        truncate_max_range = FALSE,
                                        transform = FALSE)
MyUnstainedBeadsCytoSet
```

```{r}
MyUnstainedBeadsGatingSet <- GatingSet(MyUnstainedBeadsCytoSet)
MyUnstainedBeadsGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the bead singlets. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r, message=FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyBeadsGates <- fread(file.path(path = FileLocation, 
                                pattern = 'GatesBeads.csv'))
gt(MyBeadsGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message=FALSE}
MyBeadsGatingTemplate <- gatingTemplate(MyBeadsGates)
gt_gating(MyBeadsGatingTemplate, MyUnstainedBeadsGatingSet)
MyUnstainedBeadsGatingSet[[1]]
plot(MyBeadsGatingSet)
```

And finally check the gate placements using the `Utility_GatingPlots` function:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualBeadPlot <- Utility_GatingPlots(x=MyUnstainedBeadsGatingSet[[1]], 
                                          sample.name = "GUID",
                                          removestrings = removestrings,
                                          gtFile = MyBeadsGates, 
                                          DesiredGates = NULL,
                                          outpath = StorageLocation,
                                          export = FALSE)

IndividualBeadPlot
```

## Creating a GatingSet Cell Unstained Controls
These unstained cell controls were collected for CBMC and PBMC specimens, and stimulated with either PMA-ionomycin or control. They are useful to evaluate heterogeneity present in autofluorescence across donors and treatment conditions. Having isolated the list of desired .fcs files at the start of the vignette, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyUnstainedCytoSet <- load_cytoset_from_fcs(UnstainedCells, 
                                   truncate_max_range = FALSE, 
                                   transform = FALSE)
MyUnstainedCytoSet
MyUnstainedGatingSet <- GatingSet(MyUnstainedCytoSet)
MyUnstainedGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the lymphocyte population. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message = FALSE}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyUnstainedGatingSet)
MyUnstainedGatingSet[[1]]
```

And finally check the gate placements using:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualPlot <- Utility_GatingPlots(x=MyUnstainedGatingSet[[2]], 
                                      sample.name = "GUID", 
                                      removestrings = removestrings, 
                                      gtFile = MyGates, 
                                      DesiredGates = NULL, 
                                      outpath = StorageLocation, 
                                      export = FALSE)

#IndividualPlot
  
IteratedPlots <- map(.x = MyUnstainedGatingSet[1:2], .f = Utility_GatingPlots, 
                     sample.name = "GUID", removestrings = removestrings,
                     gtFile = MyGates, DesiredGates = NULL,
                     outpath = StorageLocation, export = FALSE)

IteratedPlots[[1]]
```



# Luciernaga_QC

`Luciernaga_QC()` is the `Luciernaga` package workhorse function. It's primary purpose is to take individual .fcs files, identify normalized signatures at the level of individual cells, group cells with similar signatures together and then export the data as purified signature .fcs file or as a dataframe object for use in reports. Given the various types of unmixing controls it can encounter (beads or cells, single color or unstained), it coordinates various functions behind the scenes, while retaining similar processing and arguments to allow for user-directed inputs.  

As with other `Luciernaga` functions, `Luciernaga_QC()` starts from GatingSet objects. For this workflow, our overarching goal is to characterize signatures present within our single color cell reference controls. To do this, we will need to lay down some groundwork that will vary depending on your individual panel and experiment context. 

## Autofluorescent Overlaps

For our SFC panels, a few fluorophores (BUV496, BV510) peak signature detector overlaps directly with that of the main autofluorescent detector peaks (UV7-A, V7-A). `Luciernaga_QC` works on the basis of filtering single stained cells from unstained cells by their peak fluorescence detectors. To handle situations when these are identical, `Luciernaga_QC()` refers to an autofluorescent overlap list to appropriately handle fluorophores where this is the case. 

Since these will vary by panel and cell type in user-specific ways, to appropriately extract the background autofluorescence from these particular single colors, we need to provide information about where to expect to overlapping autofluorescent with fluorophore signatures in a .csv file.

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
AFOverlap_CSV <- read.csv(AFOverlap, check.names = FALSE)
AFOverlap_CSV
```
As you can see from the above example, we provide for Fluorophore "Unstained" the location of the peak detectors that autofluorescence (both the main autofluorescence (UV7-A, V7-A) and rarer variants (V5-A, V7-A, V8-A)) can be found on. If the rarer variants are unknown, list the main Autofluorescent detector in your system and add the exceptions to the .csv file as you encounter them in actual practice. 

The second component are individual fluorophores that overlap with the mentioned Unstained detectors. You can add/remove to this list, the crucial part is to retain the Unstained row.

Now that an initial overlap .csv has been provided, the initial steps in our workflow focus on refining what autofluorescence backgrounds we are working with. This is important not only for isolating signatures of the single-color controls, but also for handling overlap exceptions (mentioned above) as well as determining any autofluorescence(s) that might be present within individual samples that will need to be treated as individual fluorophores.

To do this without running all `Luciernaga_QC()` extraction protocols, we first set the arguments SignatureReturnNow to TRUE. We can additionally set Verbose = TRUE to get processing information that can be useful in troubleshooting. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)

removestrings <- ".fcs"

UnstainedSignature <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                    subsets="lymphocytes", 
                                    removestrings=removestrings,
                                    sample.name="GUID",
                                    unmixingcontroltype = "cells",
                                    Unstained = TRUE, 
                                    ratiopopcutoff = 0.001,
                                    Verbose = TRUE,
                                    AFOverlap = AFOverlap,
                                    stats = "median",
                                    ExportType = "data.frame",
                                    SignatureReturnNow = TRUE,
                                    outpath = NULL)
``` 

From the Verbose = TRUE readouts, we can see that the main peak detector of autofluorescence in unstained lymphocytes cells in our sample is "V7" detector, with a few cells having their respective peaks for V8, V5, V6. 

For the samples provided in this R package, we down-sampled unstained files to 10,000 event, so depending on total number of cells would inform whether these minor autofluorescent peaks are negligible or important enough to add to the above AutofluorescentOverlap.csv. 

What we see is also influcence by the ratiopopcutoff argument (set to 0.001 above). It is used to determine minimal number of cells a peak detector would need to have in order to be returned as a significant autofluorescence detector. We can be see this in action by making the argument more stringent with this argument (increase it to 0.1 ~ 10% total unstained cells share that peak detector):

```{r}
UnstainedSignature <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                    subsets="lymphocytes", 
                                    removestrings=removestrings,
                                    sample.name="GUID",
                                    unmixingcontroltype = "cells",
                                    Unstained = TRUE, 
                                    ratiopopcutoff = 0.1,
                                    Verbose = TRUE,
                                    AFOverlap = AFOverlap,
                                    stats = "median",
                                    ExportType = "data.frame",
                                    SignatureReturnNow = TRUE,
                                    outpath = NULL)
``` 

With SignatureReturnNow = TRUE, for the main peak detector present within the sample, we get an averaged signature that is returned. The average is determined by the stats argument, which is typically either "median" or "mean". 

```{r}
UnstainedSignature
```

This returned signature is what we provide as an external autofluorescence argument for either the bead or single-color controls. 

In cases where we want to return the averaged signature for a specific autofluorescene or one of the minor autofluorescent peak detectors (like V8, V5 or V6) we can add the additional argument desiredAF and set it to the corresponding detector ("V8-A"):

```{r}
V7 <- Luciernaga_QC(x=MyUnstainedGatingSet[2], desiredAF = "V7-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

V8 <- Luciernaga_QC(x=MyUnstainedGatingSet[2], desiredAF = "V8-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

V5 <- Luciernaga_QC(x=MyUnstainedGatingSet[2], desiredAF = "V5-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

Comparison <- rbind(V7, V8, V5)
gt(Comparison)
```

These averaged signature readouts can also be combined with the functions covered in the QC vignette to visualize the normalized signature:

```{r}
Fluorophore <- data.frame(Sample=c("V7", "V8", "V5"))
Data <- cbind(Fluorophore, Comparison)

SignatureOnly <- QC_WhatsThis(x="V7", data=Data, NumberHits = 0, returnPlots = TRUE)
SignatureOnly[[2]]
```

We can also compare it to reference fluorophore spectras to see what single colors it might overlap with and significantly impact:

```{r}
Comparison <- QC_WhatsThis(x="V7", data=Data, NumberHits = 5, returnPlots = TRUE)
Comparison[[1]]
```

```{r}
plotly::ggplotly(Comparison[[2]])
```

We will typically repeat the above workflow on various unstained specimens within our GatingSet, identify if any additional rare AF may be present, and then update our AFOverlap.csv to account for these Unstained peak detectors, and add any fluorophores that share their peak detector. Once this is done, we are ready to proceed. 

## Unstained Signatures

Having established autofluorescence background for the cells we are working with (and updated the AFOverlaps csv), we can now switch SignatureReturnNow = FALSE, and allow `Luciernaga_QC()` to continue down the processing pipeline. Let's continue with Unstained cell gating set, as their signatures do not require subtraction of background like single color controls, and are easier to demonstrate `Luciernaga_QC()` building blocks.

From the above example, we used `Luciernaga_QC()` to retrieve for individual detectors that passed the ratiopopcutoff limit the averaged signature of cells that shared their respective peak detectors. We can quickly visualize both the raw fluorescence and the normalized signatures using the `QC_ViewSignature()` function:

```{r}
SignatureOnly <- QC_ViewSignature(x=c("V7", "V8", "V5"), data=Data, Normalize = FALSE)
plotly::ggplotly(SignatureOnly)
```



```{r}
SignatureOnly <- QC_ViewSignature(x=c("V7", "V8", "V5"), data=Data, Normalize = TRUE)
plotly::ggplotly(SignatureOnly)
```

While this approach is good to quickly characterize average signature of cells at the population level for each detector, it can miss variation present in cells, especially for non-peak detector regions. For example, if we passed the same original unstained file to `Luciernaga_LinearSlices()`, we could see that when we cut the population for the "V7" detector in 10% increments on the basis of MFI, that we end up some variation in the normalized signatures for the secondary peaks.

```{r}
RawSlices <- Luciernaga_LinearSlices(x=MyUnstainedGatingSet[2], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="raw",
                                  probsratio=0.1, output="plot", desiredAF="V7-A")

plotly::ggplotly(RawSlices)
```


```{r}
NormalizedSlices <- Luciernaga_LinearSlices(x=MyUnstainedGatingSet[2], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="normalized",
                                  probsratio=0.1, output="plot", desiredAF="V7-A")

plotly::ggplotly(NormalizedSlices)
```

This is particularly more pronounced in single-color unmixing controls, for example, here is what CD16 APC looks like when filtered solely on the basis of peak-detector:

```{r}
#pData(MyGatingSet)

RawSlices <- Luciernaga_LinearSlices(x=MyGatingSet[6], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="raw",
                                  probsratio=0.1, output="plot", desiredAF="R1-A")

plotly::ggplotly(RawSlices)
```

```{r}
#pData(MyGatingSet[6])

NormalizedSlices <- Luciernaga_LinearSlices(x=MyGatingSet[6], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="normalized",
                                  probsratio=0.1, output="plot", desiredAF="R1-A")

plotly::ggplotly(NormalizedSlices)
```

For the dimmest cells in terms of brightness (raw MFI), the resulting normalized signatures retain significant portion of autofluorescence signature that contaminates the final normalized signature. We can compare how different these are by setting the returntype to "data" and passing the rows of comparison interest to `QC_WhatsThis()`

```{r}
NormalizedSliceData <- Luciernaga_LinearSlices(x=MyGatingSet[6], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="normalized",
                                  probsratio=0.1, output="data", desiredAF="R1-A")

APC_90to100 <- NormalizedSliceData %>% rename(Sample = Percentiles) %>% filter(Sample %in% "90")
APC_10to20 <- NormalizedSliceData %>% rename(Sample = Percentiles) %>% filter(Sample %in% "10")
```

```{r}
MatchingSignature <- QC_WhatsThis(x="90", data=APC_90to100, NumberHits = 10, returnPlots = TRUE)
MatchingSignature[1]
```
```{r}
plotly::ggplotly(MatchingSignature[[2]])
```

```{r}
ContaminationSignature <- QC_WhatsThis(x="10", data=APC_10to20, NumberHits = 10, returnPlots = TRUE)
ContaminationSignature[1]
```

```{r}
plotly::ggplotly(ContaminationSignature[[2]])
```

In this case, the cosine value of the signature from our APC single-color went from being a near match to the reference signature, to 0.76. It's because of these reasons, that in `Luciernaga_QC` after the initial peak detectors are determined, we filter cells that share this peak detector, and then determine if any additional signature peaks are present. This occurs using a rolling local maxima approach to identify these additional peaks. If the fluorophore doesn't have any additional peaks, `Luciernaga_QC()` will enumerate the first peak and move on. If they are present, individual cells are evaluated by the height of the retrieved detectors corresponding to these additional peaks vs the main peak. Ie, is the additional peak 0.5 (50%) the height, or 0.1 (10%) the height of the peak detector. 

Once this process has been repeated for each individual cell, the enumerations are appended to create a subcluster designation. For autofluorescence cells in our system, this would often resemble a name similar to V7_10-UV8_05-B3_04. With the primary peak coming first, with it's relative height equaling 10 (since R doesn't like periods to allow for a 1.0) [V7_10]. Then the second highest peak and it's relative height compared to the peak detector [-UV7_05-], and finally the final peak in the fluorescent signature and it's height relative to the peak detector [-B3_04]. Once these subcluster names are formed, they are used to group cells with similar autofluorescence together to be exported/reported as purified signatures. 

Let's see what this looks like in the context of our original unstained sample. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
removestrings <- c(".fcs")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

Unstained_Signatures <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = TRUE,
                                      ratiopopcutoff = 0.001,
                                      Verbose = FALSE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "data",
                                      SignatureReturnNow = FALSE,
                                      outpath = NULL,
                                      Increments=0.1,
                                      experiment = "UnstainedSignature",
                                      condition = "Test")
gt(head(Unstained_Signatures, 5))
```

As you can see, we have a Cluster column following the peak naming format mentioned above, as well as the count of the number of cells that shared this signature. We also get back within the data.frame the normalized signature values for respective detectors that can be used to plot the signatures.

```{r}
TheData <- Unstained_Signatures %>% select(-any_of(c("Sample", "Experiment", "Condition", "Count"))) %>% rename(Sample=Cluster)

TheFluors <- TheData %>% pull(Sample)
TheFluors <- TheFluors[1:10]

Luciernaga_Subpeaks <- QC_ViewSignature(x=TheFluors, data=TheData, Normalize = TRUE)
plotly::ggplotly(Luciernaga_Subpeaks)
```

As can be seen, this approach improves on the ability to capture the variation present within the UV8 detector. 

Two important arguments to mention are Increments and SecondaryPeaks. Increments are by default set to 0.1, so 10% increments. So if a secondary peak is 0.18 of the primary peak value, it would get rounded to the nearest 0.1 increment interval (0.2). In `Luciernaga`'s current implementation, 0.1 is the lowest value verified to work, but it can be increased more broadly to 0.2. 

```{r}
Unstained_Signatures <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = TRUE,
                                      ratiopopcutoff = 0.001,
                                      Verbose = FALSE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "data",
                                      SignatureReturnNow = FALSE,
                                      outpath = NULL,
                                      Increments=0.2,
                                      experiment = "UnstainedSignature",
                                      condition = "Test")
gt(head(Unstained_Signatures, 5))
```

```{r}
TheData <- Unstained_Signatures %>% select(-any_of(c("Sample", "Experiment", "Condition", "Count"))) %>% rename(Sample=Cluster)

TheFluors <- TheData %>% pull(Sample)
TheFluors <- TheFluors[1:10]

Luciernaga_Subpeaks <- QC_ViewSignature(x=TheFluors, data=TheData, Normalize = TRUE)
plotly::ggplotly(Luciernaga_Subpeaks)
```


Similarly, SecondaryPeaks default is set to 2, so allowing for a fluorescent with 3 separate peaks to be characterized. This works for most single-color unmixing controls, but can also be currently increased up to 8 peaks (which is used to characterize the QC bead and raw full-stained signatures elsewhere).  Let's decrease it to 1 for this example:

```{r}
Unstained_Signatures <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = TRUE,
                                      ratiopopcutoff = 0.001,
                                      Verbose = FALSE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "data",
                                      SignatureReturnNow = FALSE,
                                      outpath = NULL,
                                      Increments=0.2,
                                      SecondaryPeaks=1,
                                      experiment = "UnstainedSignature",
                                      condition = "Test")
gt(head(Unstained_Signatures, 5))
```

One challenge is that for every additional peak, at 0.1 increments, the number of potential combinations a subcluster name can take increases, the end number of subclusters increase, and the fewer cells per subcluster result. At the same time, we get into the "Poisson" noise discussion territory where only people named David typically thread. At a certain point of increasing points we are evaluating at, every single autofluorescent cell eventually clusters only with itself at the typical number of cells collected for our experiments. So my advice for now is to set the Increments and SecondaryPeak arguments for what you need to achieve stable resolution/characterization/unmixing in your particular context.

## Data Export Arguments

With all the above, we have covered all the important arguments related to Unstained cell unmixing controls. For the examples above, we specified returntype == "data", which returned the summaries that could be used for the reporting functions in `Luciernaga`. Alternatively, we could export the purified signatures as .fcs files, by setting returntype = "fcs", and providing a file path to our desired storage location via the outpath argument. These files are compatible with other flow cytometry software, and can be used to assist in unmixing. This can be useful when a single-color is experiencing quality issues, or you want to create a tag specific to a certain subtype of autofluorescence. In the context of unstained unmixing controls, this would resemble the following code:

```{r, eval=FALSE}
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")


Unstained_Signatures <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = TRUE,
                                      ratiopopcutoff = 0.001,
                                      Verbose = FALSE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "fcs",
                                      SignatureReturnNow = FALSE,
                                      outpath = StorageLocation,
                                      Increments=0.1,
                                      SecondaryPeaks=2,
                                      experiment = "UnstainedSignature",
                                      condition = "Test")
```

Similarly, in combination with `r CRANpkg("purrr")` map function, we can iterate over our GatingSet to generate subcluster .fcs files for all our Unstained samples in one go.

```{r, eval = FALSE}
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

TheUnstaineds <- map(.x=MyUnstainedGatingSet[1:3], .f=Luciernaga_QC, 
                     subsets="lymphocytes", removestrings=removestrings,
                     sample.name="GUID", unmixingcontroltype = "cells",
                     Unstained = TRUE, ratiopopcutoff = 0.001,
                     Verbose = FALSE, AFOverlap = AFOverlap, 
                     stats = "median", ExportType = "fcs",
                     SignatureReturnNow = FALSE, outpath = StorageLocation,
                     Increments=0.1, SecondaryPeaks=2,
                     experiment = "UnstainedSignature",
                     condition = "Test")
```

Additionally, providing argument Brightness = TRUE will return a .csv file with the report data. This output is used by `Luciernaga_Tree()` and a couple other of the report functions we will cover later.

```{r, eval = FALSE}
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

TheUnstaineds <- map(.x=MyUnstainedGatingSet[1:3], .f=Luciernaga_QC, 
                     subsets="lymphocytes", removestrings=removestrings,
                     sample.name="GUID", unmixingcontroltype = "cells",
                     Unstained = TRUE, ratiopopcutoff = 0.001,
                     Verbose = FALSE, AFOverlap = AFOverlap, 
                     stats = "median", ExportType = "fcs",
                     SignatureReturnNow = FALSE, outpath = StorageLocation,
                     Increments=0.1, SecondaryPeaks=2,
                     experiment = "UnstainedSignature",
                     condition = "Test", Brightness = TRUE)
```

### Single Color Unmixing Controls

Now that we have covered unstained unmixing controls, let's look at how `Luciernaga_QC()` works with single-color unmixing controls.  Let's set the returnsignaturenow = TRUE as we had done previously when starting with the unstained samples.

```{r}
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

pData(MyGatingSet[2])

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[2],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = FALSE,
                                      ratiopopcutoff = 0.01,
                                      Verbose = TRUE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "data",
                                      SignatureReturnNow = TRUE,
                                      outpath = NULL)
```
```{r}
V7 <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="V7-A")

V15 <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="V15-A")

UV7 <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="UV7-A")

V5 <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="V5-A")

data <- rbind(V7, V15, UV7, V5)
Sample <- data.frame(Sample=c("V7", "V15", "UV7", "V5"))
Data <- cbind(Sample, data)

Fluors <- Data %>% pull(Sample)
```

```{r}
Raw_Results <- QC_ViewSignature(x=Fluors, data=Data, Normalize = FALSE)
plotly::ggplotly(Raw_Results)
```


```{r}
Normalized_Results <- QC_ViewSignature(x=Fluors, data=Data) 
plotly::ggplotly(Normalized_Results)
```

As we can see from the returned peak detectors, for this BV786 single-stained unmixing control, there were 4 detectors which cells from the sample had primary peaks on. Looking at the signatures (and referencing to the results from our Unstained samples looked at previously) three are unstained peak detectors (V7, UV7, V5). Consequently, the remaining detector (V15) is likely to be of antibody-staining origin. This is particularly obvious when we look at the normalized signature. In the case of Raw MFI plot, the antibody-stained cells are way brighter than the underlying autofluorescence of cells that didn't get stained by the antibody (due to not having the antigen). 

Please note that at this stage, autofluorescence background has not yet been subtracted from the single-color unmixing control, which is why we can see for ID_V15 residual autofluorescence present in both the raw and normalized signature. In the normalized signature, it materializes as minor peaks below 0.2 at both the UV7-A and V7-A. It's this bit of background that we need to properly extract in order to provide a good signature for unmixing. 

`Luciernaga_QC()` carries this process in a similar manner for all single-color unmixing controls, enumerating peak detectors, removing those listed by the AFOverlap .csv for unstained from consideration, and then focusing on the likely antibody-stain origin detectors for further processing. 

The advantage of isolating peak detectors in this manner is that it allows `Luciernaga` to profile unusual fluorescence signals that may be present within a single-color unmixing control. These could be rarer autofluorescences, but they could also be indicators for the overall quality of the antibody-fluorophore conjugation. 

It's because of this that we can also see why the AFOverlap is needed when a fluorophore shares it's peak detector with the main autofluorescence peaks. Let's take a look at what happens with BV510 for this specific case:

```{r, error = TRUE}
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

#pData(MyGatingSet)

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[16],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = FALSE,
                                      ratiopopcutoff = 0.01,
                                      Verbose = TRUE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "data",
                                      SignatureReturnNow = TRUE,
                                      outpath = NULL)
```

In this case, the function errors out and calls for an external autofluorescence signature to be provided to the ExternalAF argument. When we look at the Verbose = TRUE message, we can see that for this particular sample, only V7 is present. We all address how to deal this shortly. 

While just working off the peak detector works quite nicely for bright fluorophores, this is not always the case. Brightness is impacted not only by the fluorophore itself, but also by the antigen density on the cell surfact that the fluorophore-conjugated antibodies latch on to. 

A good highlighting example of this more-complicated side is our PerCP-Cy5.5 CD26 unmixing control. In this panel, it was added after fixation, and had some issues with degradatation and non-specific/background staining:

```{r}
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

#pData(MyGatingSet)

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[9],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = FALSE,
                                      ratiopopcutoff = 0.01,
                                      Verbose = TRUE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "data",
                                      SignatureReturnNow = TRUE,
                                      outpath = NULL)
```

```{r}
V7 <- Luciernaga_QC(x=MyGatingSet[9], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="V7-A")

B9 <- Luciernaga_QC(x=MyGatingSet[9], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="B9-A")

UV7 <- Luciernaga_QC(x=MyGatingSet[9], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="UV7-A")

B14 <- Luciernaga_QC(x=MyGatingSet[9], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="B14-A")

R3 <- Luciernaga_QC(x=MyGatingSet[9], subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                    ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data", SignatureReturnNow = TRUE, outpath = NULL,
                    desiredAF="R3-A")

data <- rbind(V7, B9, UV7, B14, R3)
Sample <- data.frame(Sample=c("V7", "B9", "UV7", "B14", "R3"))
Data <- cbind(Sample, data)

Fluors <- Data %>% pull(Sample)
```

```{r}
Results <- QC_ViewSignature(x=Fluors, data=Data, Normalize = FALSE) 
plotly::ggplotly(Results)
```

```{r}
Results <- QC_ViewSignature(x=Fluors, data=Data) 
plotly::ggplotly(Results)
```

As we can see from the signatures, there are only a few detectors that reach peak detector status. However, unlike was the case with BV786, the peak-detectors corresponding to antibody-staining are not that much brighter than the underlying autofluorescence in terms on raw MFI. Consequently, without subtracting out the background signal, the normalized signatures end up introducing autofluorescence artefacts to what should be fluorophore specific peaks, and fluorophore contributions to what shoud be purely autofluorescence detectors. Consequently, an additional step to process single-stained cells is needed. 

One way that we can do this is through the provisioning of an external autofluorescence signature. While this is required for the autofluorescence overlap fluorophores, it is an option that can be implemented for all fluorophores if desired. 

```{r}
# pData(MyUnstainedGatingSet[1])

V7_Signature <- Luciernaga_QC(x=MyUnstainedGatingSet[1], desiredAF = "V7-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

PerCPCy55_Signatures <- Luciernaga_QC(x=MyGatingSet[9], subsets="lymphocytes", removestrings=removestrings,
                        sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                        ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                        ExportType = "data", SignatureReturnNow = FALSE, outpath = NULL,
                        experiment = "PerCP", condition = "Test", Increments=0.1, externalAF=V7_Signature)

Data <- PerCPCy55_Signatures %>% filter(Count > 60) %>% select(-Sample, -Experiment, -Condition, -Count) %>%
  rename(Sample = Cluster)

Fluorophores <- Data %>% pull(Sample)

AfterSubtraction <- QC_ViewSignature(x=Fluorophores, data=Data)

plotly::ggplotly(AfterSubtraction)
```

As we can see, we are left with signatures more closely resembling that of PerCP-Cy5.5. 

```{r}
PerCPCy5.5_Sample <- Data[1,]

x <- PerCPCy5.5_Sample %>% pull(Sample)

ThePerCPCy5.5 <- QC_WhatsThis(x=x, data=PerCPCy5.5_Sample, NumberHits = 5, returnPlots = TRUE)
ThePerCPCy5.5[1]
```

```{r}
plotly::ggplotly(ThePerCPCy5.5[[2]])
```

As we can see, this worked quite nicely. An alternative way, is to rely on an internal autofluorescence. As was the case in BV786, for many single-color unmixing controls, there are quite a few cells that remain unstained within the sample that could potentially serve as an internal autofluorescence negative. This is particularly helpful in cases where a mismatch ends up occurring vs an external unstained sample during the processing and we end up with mismatching autofluorescence. However, if the antibody has a lot of non-specific background, it can contaminate the unstained peak detectors as we saw in the case above with PerCP-Cy5.5. 

Our way of handling this when using `Luciernaga_QC()` internal negatives for subtraction is as follows. Rather than provide an externalAF, we re-use the desiredAF argument and provide the name of the main autofluorescence detector ("V7-A" in our case). After the initial peaks are characterized, the cells in a sample are initially grouped on basis of shared peak detectors. Once this is done, for each "likely" antibody detector, they are subclustered on the basis of the normalized values of both that detector and the desiredAF detector. 

What we end up with, for the case above, would be a continuum of clusters ranging from those where the antibody stain is way brighter than underlying autofluorescence (B9_10-V7_00) to cells with equal brightness for both antibody and autofluorescence (B9_10-V7_10), all the way through cells that only have autofluorescence (V7_10-B9_00). From this continuum, the bin with the least amount of "antibody" detector is selected as the "uncontaminated" autofluorescence, and these cells are filtered out, and the average autofluorescence signature is extracted from them. This in turn is subtracted from all initial subclustering cells removing the background. At this point, cells with the subtracted values are re-enumerated on basis of their peak detector, and passed onward in the function to the rolling local maxima step that was described in the unstained section of the vignette to figure out the secondary peak detectors needed to continue with the pipeline. 

Does this more complicated way work, and is it worth the hassle? Let's compare the external AF from the above to the internal AF method below:

```{r}
InternalPerCPCy55_Signatures <- Luciernaga_QC(x=MyGatingSet[9], subsets="lymphocytes", removestrings=removestrings,
                        sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                        ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                        ExportType = "data", SignatureReturnNow = FALSE, outpath = NULL,
                        experiment = "PerCP", condition = "Test", Increments=0.1, externalAF=NULL, desiredAF = "V7-A")

Data <- InternalPerCPCy55_Signatures %>% filter(Count > 60) %>% select(-Sample, -Experiment, -Condition, -Count) %>%
  rename(Sample = Cluster)

Fluorophores <- Data %>% pull(Sample)

AfterSubtraction <- QC_ViewSignature(x=Fluorophores, data=Data)

plotly::ggplotly(AfterSubtraction)
```

As you can see, there isn't much difference when it comes to the main signatures that get returned by either method (which is good considering they are the same .fcs file).
In our testing, either approach provides good results, with internal AF providing some additional usefulness in cases where the experiment required troubleshooting. Being aware of possible scenarios in which picking the least contaminated bin could cause issues will be discussed in the unmixing vignette along with the broader discussion on brightness role in the process. 

And finally for good measure, let's generate the signature for BV510 using the externalAF to demonstrate the AFOverlap cases as well. For these, in addition to provisioning the externalAF, we also provision it to the Cell_AF argument, and the name of the detector the the CellMainAF

```{r}
pData(MyGatingSet[16])

V7_Signature <- Luciernaga_QC(x=MyUnstainedGatingSet[1], desiredAF = "V7-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

BV510 <- Luciernaga_QC(x=MyGatingSet[16], subsets="lymphocytes", removestrings=removestrings,
                        sample.name="GUID", unmixingcontroltype = "cells", Unstained = FALSE,
                        ratiopopcutoff = 0.001, Verbose = FALSE, AFOverlap = AFOverlap, stats = "median",
                        ExportType = "data", SignatureReturnNow = FALSE, outpath = NULL,
                        experiment = "PerCP", condition = "Test", Increments=0.1, externalAF = V7_Signature,
                        CellAF=V7_Signature, CellMainAF="V7-A")

Data <- BV510 %>% filter(Count > 60) %>% select(-Sample, -Experiment, -Condition, -Count) %>%
  rename(Sample = Cluster)

Fluorophores <- Data %>% pull(Sample)

AfterSubtraction <- QC_WhatsThis(x=Fluorophores, data=Data, NumberHits=5, returnPlots = TRUE)

AfterSubtraction[1]
```

```{r}
plotly::ggplotly(AfterSubtraction[[2]])
```

Small rounding errors contribute to the the plateau appearance at 0.1 compared to the reference control and remain on my fix-list. 

## Data Export

In the cases above, we have been returning the `Luciernaga_QC()` ExportType to "data". Similar as was the case with the unstained, we can switch this to "fcs" to return as .fcs files that can be used in other flow cytometry software. There are a couple additional arguments that are worth explaining. SCData can be either "subtracted" or "raw", meaning whether to send to the .fcs files the subtracted (modified) values or retain the original ones "raw". The issue with raw is it is incompatible with the internal subtraction method, as there is no retained reference at the moment. Likewise, if we are planning to use the "subtracted" option for SCData and planning to use subsequent .fcs files in SpectroFlo for example, we would not want to subtract out additional autofluorescence from these files as it has already been carried out. As a workaround for the software side, provisioning NegativeType argument provides some options. "default" corresponds to nothing being added (good for reports and Luciernaga_Unmix), "artificial" which adds 500 events with detector values of 0, which can be gated on as an internal autofluorescence in SpectroFlo. And finally "samples" which is the correct designation for "raw" to return to the signature view that we were seeing. 

As you can tell, there are some bugs in this description (including Subtraction) that remain to be worked out when I have time and the paper I need to graduate is submitted and I can justify optimizing code with multiple moving parts yet again. 


## Validation

```{r, eval = FALSE}
StorageLocation <- file.path("C:", "Users", "12692", "Desktop")


SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
                                        removestrings=removestrings, sample.name="GUID",
                                        unmixingcontroltype = "cells", Unstained = FALSE,
                                        ratiopopcutoff = 0.001, Verbose = FALSE,
                                        AFOverlap = AFOverlap, stats = "median",
                                        ExportType = "fcs", SignatureReturnNow = FALSE,
                                        outpath = StorageLocation, Increments=0.1,
                                        SecondaryPeaks=2, experiment = "UnstainedSignature",
                                        condition = "Test", SCData="subtracted", NegativeType="default")

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
                                        removestrings=removestrings, sample.name="GUID",
                                        unmixingcontroltype = "cells", Unstained = FALSE,
                                        ratiopopcutoff = 0.001, Verbose = FALSE,
                                        AFOverlap = AFOverlap, stats = "median",
                                        ExportType = "fcs", SignatureReturnNow = FALSE,
                                        outpath = StorageLocation, Increments=0.1,
                                        SecondaryPeaks=2, experiment = "UnstainedSignature",
                                        condition = "Test", SCData="subtracted",NegativeType="artificial")

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
                                        removestrings=removestrings, sample.name="GUID",
                                        unmixingcontroltype = "cells", Unstained = FALSE,
                                        ratiopopcutoff = 0.001, Verbose = FALSE,
                                        AFOverlap = AFOverlap, stats = "median",
                                        ExportType = "fcs", SignatureReturnNow = FALSE,
                                        outpath = StorageLocation, Increments=0.1,
                                        SecondaryPeaks=2, experiment = "UnstainedSignature",
                                        condition = "Test", SCData="subtracted",NegativeType="samples")

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
                                        removestrings=removestrings, sample.name="GUID",
                                        unmixingcontroltype = "cells", Unstained = FALSE,
                                        ratiopopcutoff = 0.001, Verbose = FALSE,
                                        AFOverlap = AFOverlap, stats = "median",
                                        ExportType = "fcs", SignatureReturnNow = FALSE,
                                        outpath = StorageLocation, Increments=0.1,
                                        SecondaryPeaks=2, experiment = "UnstainedSignature",
                                        condition = "Test", SCData="raw",NegativeType="default")

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
                                        removestrings=removestrings, sample.name="GUID",
                                        unmixingcontroltype = "cells", Unstained = FALSE,
                                        ratiopopcutoff = 0.001, Verbose = FALSE,
                                        AFOverlap = AFOverlap, stats = "median",
                                        ExportType = "fcs", SignatureReturnNow = FALSE,
                                        outpath = StorageLocation, Increments=0.1,
                                        SecondaryPeaks=2, experiment = "UnstainedSignature",
                                        condition = "Test", SCData="raw",NegativeType="artificial")

SingleStain_Signatures <- Luciernaga_QC(x=MyGatingSet[2], subsets="lymphocytes",
                                        removestrings=removestrings, sample.name="GUID",
                                        unmixingcontroltype = "cells", Unstained = FALSE,
                                        ratiopopcutoff = 0.001, Verbose = FALSE,
                                        AFOverlap = AFOverlap, stats = "median",
                                        ExportType = "fcs", SignatureReturnNow = FALSE,
                                        outpath = StorageLocation, Increments=0.1,
                                        SecondaryPeaks=2, experiment = "UnstainedSignature",
                                        condition = "Test", SCData="raw",NegativeType="samples")

```

## Beads
In the case of unstained bead controls, it's recommended to use externalAF in this manner. In our experience with UltraComp beads, there is rarely a single peak detector for unstained beads given their low background, which causes oversplitting due to instrumental noise into hundreds of signatures. This and the rest will be detailed as we continue into the example workthrough. 

# Conclusion

You have survived writing the vignette for the most complicated of this packages functions. Congrats!

```{r sessionInfo, echo = FALSE}
sessionInfo()
```

