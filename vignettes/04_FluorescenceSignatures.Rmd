---
title: "04 Fluorescence Signatures"
date: "`r BiocStyle::doc_date()`"
author:
- name: David Rach
  email: drach@som.umaryland.edu
  affiliation: University of Maryland, Baltimore
package: "`r BiocStyle::pkg_ver('Luciernaga')`"
output:
  BiocStyle::html_document
bibliography: "`r file.path(system.file('extdata', package='Luciernaga'), 'refs.bib')`"
vignette: |
  %\VignetteIndexEntry{04 Fluorescence Signatures}
  %\VignettePackage{Luciernaga}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction
In spectral flow cytometry (SFC), having good quality unmixing controls (both single color and unstained) is critical to the ability to take a full-stained sample and be able to decipher on an individual cell basis what fluorophore is present and the relative amount. Each single color unmixing control is itself a combination of the staining fluorophore and the underlying autofluorescence. Once autofluorescence is subtracted, the leftover signal should be distinct enough to be differentiated from other fluorophores in the reference matrix for unmixing using ordinary least squares to be effective. 

When the above assumptions are broken, we end up with uncertainty in the calculation, which becomes visible in the form of unmixing errors. However, despite the importance foundational to the final result, we have limited tools by which we can address the quality of our unmixing controls beyond trial and errors. 

This specific vignette addresses the Luciernaga functions that are focused on characterizing fluorescence signatures from individual .fcs files. They work on both unstained .fcs files where no subtraction takes place, as well as on single color .fcs files, where autofluorescent background (either internally or externally-derived) is first subtracted. The outputs can be either in a data.frame format that can be used for report generation, or as purified .fcs made up of populations of cells sharing the same normalized signature. 

This vignette will cover the pre-processing and report generation components of the process. For the Unmixing steps using the resulting files, please refer to the unmixing vignette. We hope this allows a better understanding of how fluorophore signature and brightness impacts the typically ordinal least squares methods that are used to unmix full-stained samples. 

# Getting Started

To use the following Luciernaga functions, we will be working with raw .FCS files that retain their detector information (ex. UV7-A, V7-A, B3-A, etc.). We will bring these files into GatingSets comprising both unstained and single color unmixing controls, divided by whether the reference controls are cells or beads for ease of explanation.

## Install Required Packages Libraries

Luciernaga relies on the infrastructure provided by other cytometry R packages like `r Biocpkg("flowCore")` and `r Biocpkg("flowWorkspace")` available through Bioconductor. It also relies on `r CRANpkg("tidyverse")` packages available via CRAN. It is important to make sure that each of the following packages is installed on your computer before beginning. If you are new to R, an example of how to do this is provided below: 

```{r, eval=FALSE}
# To Install a CRAN Package:
install.packages("dplyr")
install.packages("BiocManager")

# To Install a Bioconductor Package:
BiocManager::install("flowCore")
```

Once you have the packages installed, you make sure that their contents are accessible by calling them via library: 

```{r, echo=FALSE, results = "hide", warning=FALSE}
suppressPackageStartupMessages({
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
})
```

```{r}
library(Luciernaga)
library(flowCore)
library(flowWorkspace)
library(openCyto)
library(ggcyto)  
library(data.table)
library(dplyr)
library(purrr) 
library(stringr)
library(ggplot2)
library(gt)
library(plotly)
library(htmltools)
```

## Locating .fcs files
To get started, you will first need to provide the location on your computer where the .fcs files of interest are being stored. An example of how the author does this is provided below and can be modified for your own user and desired computer folder. 

```{r}
File_Location <- file.path("C:", "Users", "JohnDoe", "Desktop",
                           "TodaysExperiment")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,
                        full.names = TRUE, recursive = FALSE)
```

For this vignette, we will using several small .fcs files that are stored in Luciernaga's extdata folder for use in our examples.

```{r}
File_Location <- system.file("extdata", package = "Luciernaga")
FCS_Pattern <- ".fcs$"
FCS_Files <- list.files(path = File_Location, pattern = FCS_Pattern,
                        full.names = TRUE, recursive = FALSE)
head(FCS_Files[10:30], 20)
```

As you can see, there are a lot of different .fcs files that are used for different examples for the different vignettes, we will be selectively filtering from this list to get specific files that we need. 

```{r}
UnstainedFCSFiles <- FCS_Files[grep("Unstained", FCS_Files)]
UnstainedBeads <- UnstainedFCSFiles[grep("Beads", UnstainedFCSFiles)]
UnstainedCells <- UnstainedFCSFiles[-grep("Beads", UnstainedFCSFiles)]

BeadFCSFiles <- FCS_Files[grep("Beads", FCS_Files)]
BeadSingleColors <- BeadFCSFiles[-grep("Unstained", BeadFCSFiles)]

CellSingleColorFiles <- FCS_Files[grep("Cells", FCS_Files)]
CellSingleColors <- CellSingleColorFiles[!str_detect("Unstained", CellSingleColorFiles)]
```



## Creating a GatingSet Bead Single Colors
The bead single color controls are part of a 29-color SFC panel. They additionally have cell single color equivalents that we will compare to in a separate GatingSet in the next section. 

Now that we have filtered the .fcs files into smaller list, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyBeadsCytoSet <- load_cytoset_from_fcs(BeadSingleColors,
                                        truncate_max_range = FALSE,
                                        transform = FALSE)
MyBeadsCytoSet
```

```{r}
MyBeadsGatingSet <- GatingSet(MyBeadsCytoSet)
MyBeadsGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the bead singlets. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r, message=FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyBeadsGates <- fread(file.path(path = FileLocation, 
                                pattern = 'GatesBeads.csv'))
gt(MyBeadsGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message=FALSE}
MyBeadsGatingTemplate <- gatingTemplate(MyBeadsGates)
gt_gating(MyBeadsGatingTemplate, MyBeadsGatingSet)
MyBeadsGatingSet[[1]]
plot(MyBeadsGatingSet)
```

And finally check the gate placements using the `Utility_GatingPlots` function:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualBeadPlot <- Utility_GatingPlots(x=MyBeadsGatingSet[[1]], 
                                          sample.name = "GUID",
                                          removestrings = removestrings,
                                          gtFile = MyBeadsGates, 
                                          DesiredGates = NULL,
                                          outpath = StorageLocation,
                                          export = FALSE)

IndividualBeadPlot
```

```{r}
IteratedBeadPlots <- map(.x = MyBeadsGatingSet[1:3], .f = Utility_GatingPlots,
                         sample.name = "GUID", removestrings = removestrings,
                         gtFile = MyBeadsGates, DesiredGates = NULL,
                         outpath = StorageLocation, export = FALSE)
IteratedBeadPlots


#gs_pop_get_count_fast(MyBeadsGatingSet)
```
 
## Creating a GatingSet Cell Single Colors
These cell single color controls are part of 29-color SFC panel, they are the cell counterparts to the bead reference controls we worked with in the prior section. Having isolated the list of desired .fcs files at the start of the vignette, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyCytoSet <- load_cytoset_from_fcs(CellSingleColors, 
                                   truncate_max_range = FALSE, 
                                   transform = FALSE)
MyCytoSet
MyGatingSet <- GatingSet(MyCytoSet)
MyGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the lymphocyte population. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message = FALSE}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyGatingSet)
MyGatingSet[[1]]
```

And finally check the gate placements using:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualPlot <- Utility_GatingPlots(x=MyGatingSet[[2]], 
                                      sample.name = "GUID", 
                                      removestrings = removestrings, 
                                      gtFile = MyGates, 
                                      DesiredGates = NULL, 
                                      outpath = StorageLocation, 
                                      export = FALSE)

#IndividualPlot
  
IteratedPlots <- map(.x = MyGatingSet[1:2], .f = Utility_GatingPlots, 
                     sample.name = "GUID", removestrings = removestrings,
                     gtFile = MyGates, DesiredGates = NULL,
                     outpath = StorageLocation, export = FALSE)

IteratedPlots[[2]]
```

## Creating a GatingSet Bead Unstained
This unstained Bead cell control is by itself and could have been included in the Bead Single Color Gating Set, but we are including it in its own GatingSet for ease-of-locating reasons only. Now that we have filtered the .fcs file of interest, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyUnstainedBeadsCytoSet <- load_cytoset_from_fcs(UnstainedBeads,
                                        truncate_max_range = FALSE,
                                        transform = FALSE)
MyUnstainedBeadsCytoSet
```

```{r}
MyUnstainedBeadsGatingSet <- GatingSet(MyUnstainedBeadsCytoSet)
MyUnstainedBeadsGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the bead singlets. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r, message=FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyBeadsGates <- fread(file.path(path = FileLocation, 
                                pattern = 'GatesBeads.csv'))
gt(MyBeadsGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message=FALSE}
MyBeadsGatingTemplate <- gatingTemplate(MyBeadsGates)
gt_gating(MyBeadsGatingTemplate, MyUnstainedBeadsGatingSet)
MyUnstainedBeadsGatingSet[[1]]
plot(MyBeadsGatingSet)
```

And finally check the gate placements using the `Utility_GatingPlots` function:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualBeadPlot <- Utility_GatingPlots(x=MyUnstainedBeadsGatingSet[[1]], 
                                          sample.name = "GUID",
                                          removestrings = removestrings,
                                          gtFile = MyBeadsGates, 
                                          DesiredGates = NULL,
                                          outpath = StorageLocation,
                                          export = FALSE)

IndividualBeadPlot
```

## Creating a GatingSet Cell Unstained Controls
These unstained cell controls were collected for CBMC and PBMC specimens, and stimulated with either PMA-ionomycin or control. They are useful to evaluate heterogeneity present in autofluorescence across donors and treatment conditions. Having isolated the list of desired .fcs files at the start of the vignette, we can use the `r Biocpkg("flowWorkspace")` to bring these individual .fcs files first into a CytoSet object, then into a GatingSet object that we can add gates to:

```{r}
MyUnstainedCytoSet <- load_cytoset_from_fcs(UnstainedCells, 
                                   truncate_max_range = FALSE, 
                                   transform = FALSE)
MyUnstainedCytoSet
MyUnstainedGatingSet <- GatingSet(MyUnstainedCytoSet)
MyUnstainedGatingSet
```
For this example, we will use the `r Biocpkg("openCyto")` package to automatically gate each of our .fcs files for the lymphocyte population. To do this, we first read in the example .csv file containing our desired gates (that can be found in Luciernaga's extdata folder) using the `r CRANpkg("data.table")` package

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
MyGates <- fread(file.path(path = FileLocation, pattern = 'Gates.csv'))
gt(MyGates)
```

For your own experiments, individual gates can be added, removed or modified to match the requirements of your own .fcs files, for additional details, please refer to the `r Biocpkg("openCyto")` packages vignettes. Alternatively, GatingSet objects can be brought directly from several commercial software formats using the `r Biocpkg("CytoML")` package. 

Now that we have the gating information from the .csv file, we can convert them into a GatingTemplate, and append them to the .fcs files contained within the GatingSet

```{r, message = FALSE}
MyGatingTemplate <- gatingTemplate(MyGates)
gt_gating(MyGatingTemplate, MyUnstainedGatingSet)
MyUnstainedGatingSet[[1]]
```

And finally check the gate placements using:

```{r}
removestrings <-  c("(Cells)", ".fcs", " ")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

IndividualPlot <- Utility_GatingPlots(x=MyUnstainedGatingSet[[2]], 
                                      sample.name = "GUID", 
                                      removestrings = removestrings, 
                                      gtFile = MyGates, 
                                      DesiredGates = NULL, 
                                      outpath = StorageLocation, 
                                      export = FALSE)

#IndividualPlot
  
IteratedPlots <- map(.x = MyUnstainedGatingSet[1:2], .f = Utility_GatingPlots, 
                     sample.name = "GUID", removestrings = removestrings,
                     gtFile = MyGates, DesiredGates = NULL,
                     outpath = StorageLocation, export = FALSE)

IteratedPlots[[1]]
```



# Luciernaga_QC

`Luciernaga_QC()` is the `Luciernaga` package workhorse function. It's primary purpose is to take individual .fcs files, identify normalized signatures at the level of individual cells, group cells with similar signatures together and then export the data as purified signature .fcs file or as a dataframe object for use in reports. Given the various types of unmixing controls it can encounter (beads or cells, single color or unstained), it coordinates various functions behind the scenes, while retaining similar processing and arguments to allow for user-directed inputs.  

As with other `Luciernaga` functions, `Luciernaga_QC()` starts from GatingSet objects. For this workflow, our overarching goal is to characterize signatures present within our single color cell reference controls. To do this, we will need to lay down some groundwork that will vary depending on your individual panel and experiment context. 

## Autofluorescent Overlaps

For our SFC panels, a few fluorophores (BUV496, BV510) peak signature detector overlaps directly with that of the main autofluorescent detector peaks (UV7-A, V7-A). `Luciernaga_QC` works on the basis of filtering single stained cells from unstained cells by their peak fluorescence detectors. To handle situations when these are identical, `Luciernaga_QC()` refers to an autofluorescent overlap list to appropriately handle fluorophores where this is the case. 

Since these will vary by panel and cell type in user-specific ways, to appropriately extract the background autofluorescence from these particular single colors, we need to provide information about where to expect to overlapping autofluorescent with fluorophore signatures in a .csv file.

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
AFOverlap_CSV <- read.csv(AFOverlap, check.names = FALSE)
AFOverlap_CSV
```
As you can see from the above example, we provide for Fluorophore "Unstained" the location of the peak detectors that autofluorescence (both the main autofluorescence (UV7-A, V7-A) and rarer variants (V5-A, V7-A, V8-A)) can be found on. If the rarer variants are unknown, list the main Autofluorescent detector in your system and add the exceptions to the .csv file as you encounter them in actual practice. 

The second component are individual fluorophores that overlap with the mentioned Unstained detectors. You can add/remove to this list, the crucial part is to retain the Unstained row.

Now that an initial overlap .csv has been provided, the initial steps in our workflow focus on refining what autofluorescence backgrounds we are working with. This is important not only for isolating signatures of the single-color controls, but also for handling overlap exceptions (mentioned above) as well as determining any autofluorescence(s) that might be present within individual samples that will need to be treated as individual fluorophores.

To do this without running all `Luciernaga_QC()` extraction protocols, we first set the arguments SignatureReturnNow to TRUE. We can additionally set Verbose = TRUE to get processing information that can be useful in troubleshooting. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)

removestrings <- ".fcs"

UnstainedSignature <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                    subsets="lymphocytes", 
                                    removestrings=removestrings,
                                    sample.name="GUID",
                                    unmixingcontroltype = "cells",
                                    Unstained = TRUE, 
                                    ratiopopcutoff = 0.001,
                                    Verbose = TRUE,
                                    AFOverlap = AFOverlap,
                                    stats = "median",
                                    ExportType = "data.frame",
                                    SignatureReturnNow = TRUE,
                                    outpath = NULL)
``` 

From the Verbose = TRUE readouts, we can see that the main peak detector of autofluorescence in unstained lymphocytes cells in our sample is "V7" detector, with a few cells having their respective peaks for V8, V5, V6. 

For the samples provided in this R package, we down-sampled unstained files to 10,000 event, so depending on total number of cells would inform whether these minor autofluorescent peaks are negligible or important enough to add to the above AutofluorescentOverlap.csv. 

What we see is also influcence by the ratiopopcutoff argument (set to 0.001 above). It is used to determine minimal number of cells a peak detector would need to have in order to be returned as a significant autofluorescence detector. We can be see this in action by making the argument more stringent with this argument (increase it to 0.1 ~ 10% total unstained cells share that peak detector):

```{r}
UnstainedSignature <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                    subsets="lymphocytes", 
                                    removestrings=removestrings,
                                    sample.name="GUID",
                                    unmixingcontroltype = "cells",
                                    Unstained = TRUE, 
                                    ratiopopcutoff = 0.1,
                                    Verbose = TRUE,
                                    AFOverlap = AFOverlap,
                                    stats = "median",
                                    ExportType = "data.frame",
                                    SignatureReturnNow = TRUE,
                                    outpath = NULL)
``` 

With SignatureReturnNow = TRUE, for the main peak detector present within the sample, we get an averaged signature that is returned. The average is determined by the stats argument, which is typically either "median" or "mean". 

```{r}
UnstainedSignature
```

This returned signature is what we provide as an external autofluorescence argument for either the bead or single-color controls. 

In cases where we want to return the averaged signature for a specific autofluorescene or one of the minor autofluorescent peak detectors (like V8, V5 or V6) we can add the additional argument desiredAF and set it to the corresponding detector ("V8-A"):

```{r}
V7 <- Luciernaga_QC(x=MyUnstainedGatingSet[2], desiredAF = "V7-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

V8 <- Luciernaga_QC(x=MyUnstainedGatingSet[2], desiredAF = "V8-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

V5 <- Luciernaga_QC(x=MyUnstainedGatingSet[2], desiredAF = "V5-A",
                    subsets="lymphocytes", removestrings=removestrings,
                    sample.name="GUID", unmixingcontroltype = "cells",
                    Unstained = TRUE, ratiopopcutoff = 0.001, Verbose = FALSE,
                    AFOverlap = AFOverlap, stats = "median",
                    ExportType = "data.frame", SignatureReturnNow = TRUE,
                    outpath = NULL)

Comparison <- rbind(V7, V8, V5)
gt(Comparison)
```

These averaged signature readouts can also be combined with the functions covered in the QC vignette to visualize the normalized signature:

```{r}
Fluorophore <- data.frame(Sample=c("V7", "V8", "V5"))
Data <- cbind(Fluorophore, Comparison)

SignatureOnly <- QC_WhatsThis(x="V7", data=Data, NumberHits = 0, returnPlots = TRUE)
SignatureOnly[[2]]
```

We can also compare it to reference fluorophore spectras to see what single colors it might overlap with and significantly impact:

```{r}
Comparison <- QC_WhatsThis(x="V7", data=Data, NumberHits = 5, returnPlots = TRUE)
Comparison[[1]]
```

```{r}
plotly::ggplotly(Comparison[[2]])
```

We will typically repeat the above workflow on various unstained specimens within our GatingSet, identify if any additional rare AF may be present, and then update our AFOverlap.csv to account for these Unstained peak detectors, and add any fluorophores that share their peak detector. Once this is done, we are ready to proceed. 

## Unstained Signatures

Having established autofluorescence background for the cells we are working with (and updated the AFOverlaps csv), we can now switch SignatureReturnNow = FALSE, and allow `Luciernaga_QC()` to continue down the processing pipeline. Let's continue with Unstained cell gating set, as their signatures do not require subtraction of background like single color controls, and are easier to demonstrate `Luciernaga_QC()` building blocks.

From the above example, we used `Luciernaga_QC()` to retrieve for individual detectors that passed the ratiopopcutoff limit the averaged signature of cells that shared their respective peak detectors. We can quickly visualize both the raw fluorescence and the normalized signatures using the `QC_ViewSignature()` function:

```{r}
SignatureOnly <- QC_ViewSignature(x=c("V7", "V8", "V5"), data=Data, Normalize = FALSE)
plotly::ggplotly(SignatureOnly)
```



```{r}
SignatureOnly <- QC_ViewSignature(x=c("V7", "V8", "V5"), data=Data, Normalize = TRUE)
plotly::ggplotly(SignatureOnly)
```

While this approach is good to quickly characterize average signature of cells at the population level for each detector, it can miss variation present in cells, especially for non-peak detector regions. For example, if we passed the same original unstained file to `Luciernaga_LinearSlices()`, we could see that when we cut the population for the "V7" detector in 10% increments on the basis of MFI, that we end up some variation in the normalized signatures for the secondary peaks.

```{r}
RawSlices <- Luciernaga_LinearSlices(x=MyUnstainedGatingSet[2], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="raw",
                                  probsratio=0.1, output="plot", desiredAF="V7-A")

plotly::ggplotly(RawSlices)
```


```{r}
NormalizedSlices <- Luciernaga_LinearSlices(x=MyUnstainedGatingSet[2], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="normalized",
                                  probsratio=0.1, output="plot", desiredAF="V7-A")

plotly::ggplotly(NormalizedSlices)
```

This is particularly more pronounced in single-color unmixing controls, for example, here is what CD16 APC looks like when filtered solely on the basis of peak-detector:

```{r}
pData(MyGatingSet)

RawSlices <- Luciernaga_LinearSlices(x=MyGatingSet[6], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="raw",
                                  probsratio=0.1, output="plot", desiredAF="R1-A")

plotly::ggplotly(RawSlices)
```

```{r}
#pData(MyGatingSet[6])

NormalizedSlices <- Luciernaga_LinearSlices(x=MyGatingSet[6], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="normalized",
                                  probsratio=0.1, output="plot", desiredAF="R1-A")

plotly::ggplotly(NormalizedSlices)
```

For the dimmest cells in terms of brightness (raw MFI), the resulting normalized signatures retain significant portion of autofluorescence signature that contaminates the final normalized signature. We can compare how different these are by setting the returntype to "data" and passing the rows of comparison interest to `QC_WhatsThis()`

```{r}
NormalizedSliceData <- Luciernaga_LinearSlices(x=MyGatingSet[6], subset="lymphocytes",
                                  sample.name="GUID", removestrings=removestrings,
                                  stats="median", returntype="normalized",
                                  probsratio=0.1, output="data", desiredAF="R1-A")

APC_90to100 <- NormalizedSliceData %>% rename(Sample = Percentiles) %>% filter(Sample %in% "90")
APC_10to20 <- NormalizedSliceData %>% rename(Sample = Percentiles) %>% filter(Sample %in% "10")
```

```{r}
MatchingSignature <- QC_WhatsThis(x="90", data=APC_90to100, NumberHits = 10, returnPlots = TRUE)
MatchingSignature[1]
```
```{r}
plotly::ggplotly(MatchingSignature[[2]])
```

```{r}
ContaminationSignature <- QC_WhatsThis(x="10", data=APC_10to20, NumberHits = 10, returnPlots = TRUE)
ContaminationSignature[1]
```

```{r}
plotly::ggplotly(ContaminationSignature[[2]])
```

In this case, the cosine value of the signature from our APC single-color went from being a near match to the reference signature, to 0.76. It's because of these reasons, that in `Luciernaga_QC` after the initial peak detectors are determined, we filter cells that share this peak detector, and then determine if any additional signature peaks are present. This occurs using a rolling local maxima approach to identify these additional peaks. If the fluorophore doesn't have any additional peaks, `Luciernaga_QC()` will enumerate the first peak and move on. If they are present, individual cells are evaluated by the height of the retrieved detectors corresponding to these additional peaks vs the main peak. Ie, is the additional peak 0.5 (50%) the height, or 0.1 (10%) the height of the peak detector. 

Once this process has been repeated for each individual cell, the enumerations are appended to create a subcluster designation. For autofluorescence cells in our system, this would often resemble a name similar to V7_10-UV8_05-B3_04. With the primary peak coming first, with it's relative height equaling 10 (since R doesn't like periods to allow for a 1.0) [V7_10]. Then the second highest peak and it's relative height compared to the peak detector [-UV7_05-], and finally the final peak in the fluorescent signature and it's height relative to the peak detector [-B3_04]. Once these subcluster names are formed, they are used to group cells with similar autofluorescence together to be exported/reported as purified signatures. 

Let's see what this looks like in the context of our original unstained sample. 

```{r}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
removestrings <- c(".fcs")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

Unstained_Signatures <- Luciernaga_QC(x=MyUnstainedGatingSet[2],
                                      subsets="lymphocytes",
                                      removestrings=removestrings,
                                      sample.name="GUID",
                                      unmixingcontroltype = "cells",
                                      Unstained = TRUE,
                                      ratiopopcutoff = 0.001,
                                      Verbose = FALSE,
                                      AFOverlap = AFOverlap, 
                                      stats = "median",
                                      ExportType = "data",
                                      SignatureReturnNow = FALSE,
                                      outpath = NULL,
                                      Increments=0.1,
                                      experiment = "UnstainedSignature",
                                      condition = "Test")
gt(head(Unstained_Signatures, 5))
```

As you can see, we have a Cluster column following the peak naming format mentioned above, as well as the count of the number of cells that shared this signature. We also get back within the data.frame the normalized signature values for respective detectors that can be used to plot the signatures.

```{r}
TheData <- Unstained_Signatures %>% select(-any_of(c("Sample", "Experiment", "Condition", "Count"))) %>% rename(Sample=Cluster)

TheFluors <- TheData %>% pull(Sample)
TheFluors <- TheFluors[1:10]

Luciernaga_Subpeaks <- QC_ViewSignature(x=TheFluors, data=TheData, Normalize = TRUE)
plotly::ggplotly(Luciernaga_Subpeaks)
```

As can be seen, this approach improves on the ability to capture the variation present within the UV8 detector. 




The next set of arguments we will set returntype = "data" for our examples to generate a report style. If we wanted the purified signatures returned as .fcs files, we would set this argument to "fcs" and provide an file.path to our desired storage location with the outpath argument (currently set to NULL).





Increments is a value I ask user to specify, because it determines how strict the clustering of cells on the basis of their peaks is. 





### Continue Here



We are now setup to run `Luciernaga_QC()`. It first brings in the individual .fcs file and attempts to identify for individual cells which detector their peak fluorescent emission is on. For example, single color stained cells with APC would have fluorescent emission peak on R1-A detector, while unstained PBMCs in the sample would have their fluorescent emission peak on the V7-A detector. `Luciernaga_QC()` will then enumerate for all cells in the sample which detectors account for most emission peaks. 

Now that the peaks are enumerated, it uses the information provided by the autofluorescent overlap .CSV to ignore the AF detectors, and focus on remaining detectors that likely correspond to the staining single color (with special exception handling for when fluorophore and autofluorescence detector are identical). This allows the retention of cells stained with the single-color stain from all other unstained autofluorescent cells.

The subsequent step is to remove autofluorescence contribution to reveal single-color signature alone. Autofluorescence can be defined either internally or with an external provided reference. Once autofluorescence is subtracted, cells with similar signatures are clustered together, and exported as .raw fcs files with the subcluster designation appended to the .fcs file name. 




In the case ofsingle color unmixing control (in this case, APC-Fire 750, the other specimen in our GatingSet):

```{r}
SC_InternalAF <- Luciernaga_QC(x=MyGatingSet[1], subsets="lymphocytes",
                               removestrings=removestrings, sample.name="GUID", 
                               unmixingcontroltype = "cells", Unstained = FALSE,
                               ratiopopcutoff = 0.01, Verbose = TRUE,
                               AFOverlap = AFOverlap, stats = "median",
                               ExportType = "data.frame",
                               SignatureReturnNow = TRUE, 
                               outpath = NULL, Brightness = FALSE)
SC_InternalAF
```

As you can see from the Verbose=TRUE return arguments, the main detector present in this sample was R7 (the single-color stained cells), but additional detector peaks are present for the autofluorescences we saw in the above example of the unstained cell. These can be extracted as data.frame values similar to the process above, including use of the desiredAF argument, for average signature plotting. The one caveat is they will include both fully unstained cells, as well as non-specific/dim staining cells for APC-Fire 750 that didn't exceed the brightness of the main autofluorescent signature. Luciernaga futher sorts these, so exporting these for future use is not recommended, but is useful for some initial visualization purposes. 

A special note about beads.
In the case of unstained bead controls, it's recommended to use externalAF in this manner. In our experience with UltraComp beads, there is rarely a single peak detector for unstained beads given their low background, which causes oversplitting due to instrumental noise into hundreds of signatures. This and the rest will be detailed as we continue into the example workthrough. 

Continuing, we will switch SignatureReturnNow to False. Each of the peak detectors that has more events than specified by the ratiopopcutoff will be passed on to the unstained autofluorescence processing module, which will filter by these peak detectors and proceed to characterize their peaks.

```{r}

```

And for single-color controls:

```{r, eval = FALSE, echo=FALSE}
FileLocation <- system.file("extdata", package = "Luciernaga")
pattern = "AutofluorescentOverlaps.csv"
AFOverlap <- list.files(path=FileLocation, pattern=pattern,
                        full.names = TRUE)
removestrings <- c(".fcs", "(Cells)")
StorageLocation <- file.path("C:", "Users", "JohnDoe", "Desktop")

Luciernaga_QC(x=MyGatingSet[1], subsets="lymphocytes",
              sample.name="GUID", experiment = "Monocytes", condition = "exvivo",
              removestrings = removestrings, Verbose = FALSE,
              unmixingcontroltype="both", Unstained=FALSE,
              ratiopopcutoff = 0.01, AFOverlap=AFOverlap, desiredAF="V3-A",
              externalAF = NULL, stats = "median",
              NegativeType = "artificial", ExportType = "fcs",
              outpath=StorageLocation, Brightness = TRUE,
              SignatureReturnNow = FALSE, minimalfcscutoff = 0.05,
              Subtraction = "Internal", SCData = "subtracted",
              Increments=0.1)
```

And finally, we can RetainedType = "normalized and ExportType = "data"
```{r, eval=FALSE}

Data <- Luciernaga_QC(x=MyGatingSet[1], subsets="lymphocytes",
                      sample.name="GUID", 
                      experiment = "Monocytes", condition = "exvivo",
                      removestrings = removestrings, Verbose = FALSE, 
                      unmixingcontroltype="both", Unstained=FALSE,
                      ratiopopcutoff = 0.01, AFOverlap=AFOverlap,
                      desiredAF=NULL, externalAF = NULL, stats = "median",
                      NegativeType = "artificial", ExportType = "data",
                      outpath=StorageLocation, Brightness = TRUE, 
                      SignatureReturnNow = FALSE, minimalfcscutoff = 0.05,
                      Subtraction = "Internal", SCData = "subtracted",
                      RetainedType="normalized", Increments=0.2)

CombinedData <- map(.x=MyGatingSet, .f=Luciernaga_QC, subsets="lymphocytes",
                    sample.name="GUID", experiment = "Monocytes", 
                    condition = "exvivo", removestrings = removestrings,
                    Verbose = FALSE, unmixingcontroltype="both", 
                    Unstained=FALSE, ratiopopcutoff = 0.01, AFOverlap=AFOverlap,
                    desiredAF=NULL, externalAF = NULL, stats = "median",
                    NegativeType = "artificial", ExportType = "data",
                    outpath=StorageLocation, Brightness = TRUE,
                    SignatureReturnNow = FALSE, minimalfcscutoff = 0.05,
                    Subtraction = "Internal", SCData = "subtracted",
                    RetainedType="normalized", Increments=0.2) %>% bind_rows()
```

### Luciernaga_Plots

We can take the data.frame output from LuciernagaQC and run directly into a basic report. CellPopRatio determines the mininum ratio a cluster needs to have to be plotted (anything smaller is combined into the other category). The default is set for all four plots being returned, these can be modified by specifying FALSE for their individual arguments. Outputs are sent to Utility_Patchwork for processing into either grouped ggplot or a pdf file. 

```{r, eval = FALSE, echo=FALSE}
ThePlots <- LuciernagaReport(data=CombinedData, RetainedType = "normalized",
                             CellPopRatio = 0.05, outfolder = NULL,
                             filename = NULL, returntype = "patchwork")

ThePlots
#ggplotly(ThePlots[[1]])
```


### Reports from .fcs files

The LuciernagaQC() will also produce .fcs files containing only the isolated signatures, and store these in the designated folder. Rather than re-running LuciernagaQC() just to return a report, and to allow for visualization of specific .fcs subfiles of interest, we have implemented functions that carry out similar functionality, but using these isolated fluorescent files as their start basis.

## Luciernaga_QC

## Luciernaga_FCSToReport

## Luciernaga_Brightness

## Luciernaga_Lists

## Luciernaga_Plots

# Conclusion

```{r sessionInfo, echo = FALSE}
sessionInfo()
```

